var $kZqDi$reactariautils = require("@react-aria/utils");
var $kZqDi$react = require("react");
var $kZqDi$reactariainteractions = require("@react-aria/interactions");
var $kZqDi$reactariai18n = require("@react-aria/i18n");
var $kZqDi$reactariavisuallyhidden = require("@react-aria/visually-hidden");
var $kZqDi$reactariaslider = require("@react-aria/slider");
var $kZqDi$reactariatextfield = require("@react-aria/textfield");
var $kZqDi$reactariaspinbutton = require("@react-aria/spinbutton");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useColorArea", () => $47925bd68062ac17$export$2f92a7a615a014f6);
$parcel$export(module.exports, "useColorSlider", () => $afbb9647440a7f5b$export$106b7a4e66508f66);
$parcel$export(module.exports, "useColorWheel", () => $1d29bf243d4a9a53$export$9064ff4e44b3729a);
$parcel$export(module.exports, "useColorField", () => $58c850037bc7a7ce$export$77e32ca575a28fdf);

var $4f97b428b4cbcd4e$exports = {};
var $f141a15c3076a67b$exports = {};
$f141a15c3076a67b$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `أداة انتقاء اللون`,
    "twoDimensionalSlider": `مُنزلق 2D`
};


var $435ac2a9fdd2ae5e$exports = {};
$435ac2a9fdd2ae5e$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Средство за избиране на цвят`,
    "twoDimensionalSlider": `2D плъзгач`
};


var $6b29758b432284f5$exports = {};
$6b29758b432284f5$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Výběr barvy`,
    "twoDimensionalSlider": `2D posuvník`
};


var $357597bcf4afd6fb$exports = {};
$357597bcf4afd6fb$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Farvevælger`,
    "twoDimensionalSlider": `2D-skyder`
};


var $ddc6333960e2b591$exports = {};
$ddc6333960e2b591$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Farbwähler`,
    "twoDimensionalSlider": `2D-Schieberegler`
};


var $417ee93d3ca474c0$exports = {};
$417ee93d3ca474c0$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Επιλογέας χρωμάτων`,
    "twoDimensionalSlider": `Ρυθμιστικό 2D`
};


var $519561bc6dcff98b$exports = {};
$519561bc6dcff98b$exports = {
    "colorPicker": `Color picker`,
    "twoDimensionalSlider": `2D slider`,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
};


var $7a34c3fcc03402b8$exports = {};
$7a34c3fcc03402b8$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Selector de color`,
    "twoDimensionalSlider": `Regulador 2D`
};


var $860f86d6eae22cba$exports = {};
$860f86d6eae22cba$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Värvivalija`,
    "twoDimensionalSlider": `2D-liugur`
};


var $8525d3c77b8a51b0$exports = {};
$8525d3c77b8a51b0$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Värimuokkain`,
    "twoDimensionalSlider": `2D-liukusäädin`
};


var $8240fe6825e900ec$exports = {};
$8240fe6825e900ec$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name} : ${args.value}`
    ,
    "colorPicker": `Sélecteur de couleurs`,
    "twoDimensionalSlider": `Curseur 2D`
};


var $377849238307c673$exports = {};
$377849238307c673$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `בוחר הצבעים`,
    "twoDimensionalSlider": `מחוון דו מימדי`
};


var $5a6f44e0ec14b083$exports = {};
$5a6f44e0ec14b083$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Odabir boje`,
    "twoDimensionalSlider": `2D klizač`
};


var $82327d6e71e3e273$exports = {};
$82327d6e71e3e273$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Színválasztó`,
    "twoDimensionalSlider": `2D-csúszka`
};


var $b1e297275c248ab8$exports = {};
$b1e297275c248ab8$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Selettore colore`,
    "twoDimensionalSlider": `Cursore 2D`
};


var $b39c9f2638b4d2b9$exports = {};
$b39c9f2638b4d2b9$exports = {
    "colorInputLabel": (args)=>`${args.label}、${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name} : ${args.value}`
    ,
    "colorPicker": `カラーピッカー`,
    "twoDimensionalSlider": `2D スライダー`
};


var $2d2fbf4195848a62$exports = {};
$2d2fbf4195848a62$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `색상 피커`,
    "twoDimensionalSlider": `2D 슬라이더`
};


var $ea88350d0828fa2c$exports = {};
$ea88350d0828fa2c$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Spalvų parinkiklis`,
    "twoDimensionalSlider": `2D slankiklis`
};


var $0e0acd541630120a$exports = {};
$0e0acd541630120a$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Krāsu atlasītājs`,
    "twoDimensionalSlider": `2D slīdnis`
};


var $952a458224052046$exports = {};
$952a458224052046$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Fargevelger`,
    "twoDimensionalSlider": `2D-glidebryter`
};


var $2d8e195bc5683483$exports = {};
$2d8e195bc5683483$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Kleurkiezer`,
    "twoDimensionalSlider": `2D-schuifregelaar`
};


var $750d83f83c5f38d4$exports = {};
$750d83f83c5f38d4$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Próbnik kolorów`,
    "twoDimensionalSlider": `Suwak 2D`
};


var $656b2846f611067c$exports = {};
$656b2846f611067c$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Seletor de cores`,
    "twoDimensionalSlider": `Controle deslizante 2D`
};


var $58ce120874d069dd$exports = {};
$58ce120874d069dd$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Seletor de cores`,
    "twoDimensionalSlider": `Controle deslizante 2D`
};


var $fd6c85b4eba18825$exports = {};
$fd6c85b4eba18825$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Selector de culori`,
    "twoDimensionalSlider": `Glisor 2D`
};


var $8849a15ecc435984$exports = {};
$8849a15ecc435984$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Палитра цветов`,
    "twoDimensionalSlider": `Ползунок 2D`
};


var $5192372f064be783$exports = {};
$5192372f064be783$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Výber farieb`,
    "twoDimensionalSlider": `2D jazdec`
};


var $094525f9176df65d$exports = {};
$094525f9176df65d$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Izbirnik barv`,
    "twoDimensionalSlider": `2D drsnik`
};


var $9795aa59b4ad40ed$exports = {};
$9795aa59b4ad40ed$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Birač boja`,
    "twoDimensionalSlider": `2D klizač`
};


var $9ebaa0b485f13e4d$exports = {};
$9ebaa0b485f13e4d$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Färgväljaren`,
    "twoDimensionalSlider": `2D-reglage`
};


var $ad58e2e4e0f2e750$exports = {};
$ad58e2e4e0f2e750$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Renk Seçici`,
    "twoDimensionalSlider": `2D sürgü`
};


var $dafc19306f8b2dfc$exports = {};
$dafc19306f8b2dfc$exports = {
    "colorInputLabel": (args)=>`${args.label}, ${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}: ${args.value}`
    ,
    "colorPicker": `Палітра кольорів`,
    "twoDimensionalSlider": `Повзунок 2D`
};


var $d31a8b80af5acc16$exports = {};
$d31a8b80af5acc16$exports = {
    "colorInputLabel": (args)=>`${args.label}、${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}：${args.value}`
    ,
    "colorPicker": `拾色器`,
    "twoDimensionalSlider": `2D 滑块`
};


var $7377d28aec5fa200$exports = {};
$7377d28aec5fa200$exports = {
    "colorInputLabel": (args)=>`${args.label}，${args.channelLabel}`
    ,
    "colorNameAndValue": (args)=>`${args.name}：${args.value}`
    ,
    "colorPicker": `檢色器`,
    "twoDimensionalSlider": `2D 滑桿`
};


$4f97b428b4cbcd4e$exports = {
    "ar-AE": $f141a15c3076a67b$exports,
    "bg-BG": $435ac2a9fdd2ae5e$exports,
    "cs-CZ": $6b29758b432284f5$exports,
    "da-DK": $357597bcf4afd6fb$exports,
    "de-DE": $ddc6333960e2b591$exports,
    "el-GR": $417ee93d3ca474c0$exports,
    "en-US": $519561bc6dcff98b$exports,
    "es-ES": $7a34c3fcc03402b8$exports,
    "et-EE": $860f86d6eae22cba$exports,
    "fi-FI": $8525d3c77b8a51b0$exports,
    "fr-FR": $8240fe6825e900ec$exports,
    "he-IL": $377849238307c673$exports,
    "hr-HR": $5a6f44e0ec14b083$exports,
    "hu-HU": $82327d6e71e3e273$exports,
    "it-IT": $b1e297275c248ab8$exports,
    "ja-JP": $b39c9f2638b4d2b9$exports,
    "ko-KR": $2d2fbf4195848a62$exports,
    "lt-LT": $ea88350d0828fa2c$exports,
    "lv-LV": $0e0acd541630120a$exports,
    "nb-NO": $952a458224052046$exports,
    "nl-NL": $2d8e195bc5683483$exports,
    "pl-PL": $750d83f83c5f38d4$exports,
    "pt-BR": $656b2846f611067c$exports,
    "pt-PT": $58ce120874d069dd$exports,
    "ro-RO": $fd6c85b4eba18825$exports,
    "ru-RU": $8849a15ecc435984$exports,
    "sk-SK": $5192372f064be783$exports,
    "sl-SI": $094525f9176df65d$exports,
    "sr-SP": $9795aa59b4ad40ed$exports,
    "sv-SE": $9ebaa0b485f13e4d$exports,
    "tr-TR": $ad58e2e4e0f2e750$exports,
    "uk-UA": $dafc19306f8b2dfc$exports,
    "zh-CN": $d31a8b80af5acc16$exports,
    "zh-TW": $7377d28aec5fa200$exports
};




const $99936ad0bf67c8c4$var$generateRGB_R = (orientation, dir, zValue)=>{
    let maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    let result = {
        colorAreaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
        },
        gradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
            'WebkitMaskImage': maskImage,
            maskImage: maskImage
        }
    };
    return result;
};
const $99936ad0bf67c8c4$var$generateRGB_G = (orientation, dir, zValue)=>{
    let maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    let result = {
        colorAreaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
        },
        gradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
            'WebkitMaskImage': maskImage,
            maskImage: maskImage
        }
    };
    return result;
};
const $99936ad0bf67c8c4$var$generateRGB_B = (orientation, dir, zValue)=>{
    let maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    let result = {
        colorAreaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
        },
        gradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
            'WebkitMaskImage': maskImage,
            maskImage: maskImage
        }
    };
    return result;
};
const $99936ad0bf67c8c4$var$generateHSL_H = (orientation, dir, zValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
                `hsl(${zValue}, 100%, 50%)`
            ].join(',')
        }
    };
    return result;
};
const $99936ad0bf67c8c4$var$generateHSL_S = (orientation, dir, alphaValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                'hsl(0, 0%, 50%)'
            ].join(',')
        }
    };
    return result;
};
const $99936ad0bf67c8c4$var$generateHSL_L = (orientation, dir, zValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            backgroundImage: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
            ].join(',')
        }
    };
    return result;
};
const $99936ad0bf67c8c4$var$generateHSB_H = (orientation, dir, zValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
                `hsl(${zValue}, 100%, 50%)`
            ].join(',')
        }
    };
    return result;
};
const $99936ad0bf67c8c4$var$generateHSB_S = (orientation, dir, alphaValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
            ].join(',')
        }
    };
    return result;
};
const $99936ad0bf67c8c4$var$generateHSB_B = (orientation, dir, alphaValue)=>{
    let result = {
        colorAreaStyles: {
        },
        gradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                '#000'
            ].join(',')
        }
    };
    return result;
};
function $99936ad0bf67c8c4$export$dd62420467d245ca({ direction: direction , state: state , zChannel: zChannel , xChannel: xChannel , isDisabled: isDisabled  }) {
    let returnVal = $kZqDi$react.useMemo(()=>{
        let orientation = [
            'top',
            direction === 'rtl' ? 'left' : 'right'
        ];
        let dir = false;
        let background = {
            colorAreaStyles: {
            },
            gradientStyles: {
            }
        };
        let zValue = state.value.getChannelValue(zChannel);
        let { minValue: zMin , maxValue: zMax  } = state.value.getChannelRange(zChannel);
        let alphaValue = (zValue - zMin) / (zMax - zMin);
        let isHSL = state.value.getColorSpace() === 'hsl';
        if (!isDisabled) switch(zChannel){
            case 'red':
                dir = xChannel === 'green';
                background = $99936ad0bf67c8c4$var$generateRGB_R(orientation, dir, zValue);
                break;
            case 'green':
                dir = xChannel === 'red';
                background = $99936ad0bf67c8c4$var$generateRGB_G(orientation, dir, zValue);
                break;
            case 'blue':
                dir = xChannel === 'red';
                background = $99936ad0bf67c8c4$var$generateRGB_B(orientation, dir, zValue);
                break;
            case 'hue':
                dir = xChannel !== 'saturation';
                if (isHSL) background = $99936ad0bf67c8c4$var$generateHSL_H(orientation, dir, zValue);
                else background = $99936ad0bf67c8c4$var$generateHSB_H(orientation, dir, zValue);
                break;
            case 'saturation':
                dir = xChannel === 'hue';
                if (isHSL) background = $99936ad0bf67c8c4$var$generateHSL_S(orientation, dir, alphaValue);
                else background = $99936ad0bf67c8c4$var$generateHSB_S(orientation, dir, alphaValue);
                break;
            case 'brightness':
                dir = xChannel === 'hue';
                background = $99936ad0bf67c8c4$var$generateHSB_B(orientation, dir, alphaValue);
                break;
            case 'lightness':
                dir = xChannel === 'hue';
                background = $99936ad0bf67c8c4$var$generateHSL_L(orientation, dir, zValue);
                break;
        }
        let { x: x , y: y  } = state.getThumbPosition();
        if (direction === 'rtl') x = 1 - x;
        let forcedColorAdjustNoneStyle = {
            forcedColorAdjust: 'none'
        };
        return {
            colorAreaStyleProps: {
                style: {
                    position: 'relative',
                    touchAction: 'none',
                    ...forcedColorAdjustNoneStyle,
                    ...background.colorAreaStyles
                }
            },
            gradientStyleProps: {
                style: {
                    touchAction: 'none',
                    ...forcedColorAdjustNoneStyle,
                    ...background.gradientStyles
                }
            },
            thumbStyleProps: {
                style: {
                    position: 'absolute',
                    left: `${x * 100}%`,
                    top: `${y * 100}%`,
                    transform: 'translate(0%, 0%)',
                    touchAction: 'none',
                    ...forcedColorAdjustNoneStyle
                }
            }
        };
    }, [
        direction,
        state,
        zChannel,
        xChannel,
        isDisabled
    ]);
    return returnVal;
}





function $47925bd68062ac17$export$2f92a7a615a014f6(props, state) {
    let { isDisabled: isDisabled , inputXRef: inputXRef , inputYRef: inputYRef , containerRef: containerRef , 'aria-label': ariaLabel  } = props;
    let stringFormatter = $kZqDi$reactariai18n.useLocalizedStringFormatter((/*@__PURE__*/$parcel$interopDefault($4f97b428b4cbcd4e$exports)));
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $kZqDi$reactariautils.useGlobalListeners();
    let { direction: direction , locale: locale  } = $kZqDi$reactariai18n.useLocale();
    let focusedInputRef = $kZqDi$react.useRef(null);
    let focusInput = $kZqDi$react.useCallback((inputRef = inputXRef)=>{
        if (inputRef.current) $kZqDi$reactariautils.focusWithoutScrolling(inputRef.current);
    }, [
        inputXRef
    ]);
    let stateRef = $kZqDi$react.useRef(null);
    stateRef.current = state;
    let { xChannel: xChannel , yChannel: yChannel , zChannel: zChannel  } = stateRef.current.channels;
    let xChannelStep1 = stateRef.current.xChannelStep;
    let yChannelStep1 = stateRef.current.yChannelStep;
    let currentPosition = $kZqDi$react.useRef(null);
    let { keyboardProps: keyboardProps  } = $kZqDi$reactariainteractions.useKeyboard({
        onKeyDown (e) {
            // these are the cases that useMove doesn't handle
            if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {
                e.continuePropagation();
                return;
            }
            // same handling as useMove, don't need to stop propagation, useKeyboard will do that for us
            e.preventDefault();
            // remember to set this and unset it so that onChangeEnd is fired
            stateRef.current.setDragging(true);
            valueChangedViaKeyboard.current = true;
            switch(e.key){
                case 'PageUp':
                    stateRef.current.incrementY(stateRef.current.yChannelPageStep);
                    focusedInputRef.current = inputYRef.current;
                    break;
                case 'PageDown':
                    stateRef.current.decrementY(stateRef.current.yChannelPageStep);
                    focusedInputRef.current = inputYRef.current;
                    break;
                case 'Home':
                    direction === 'rtl' ? stateRef.current.incrementX(stateRef.current.xChannelPageStep) : stateRef.current.decrementX(stateRef.current.xChannelPageStep);
                    focusedInputRef.current = inputXRef.current;
                    break;
                case 'End':
                    direction === 'rtl' ? stateRef.current.decrementX(stateRef.current.xChannelPageStep) : stateRef.current.incrementX(stateRef.current.xChannelPageStep);
                    focusedInputRef.current = inputXRef.current;
                    break;
            }
            stateRef.current.setDragging(false);
            if (focusedInputRef.current) focusInput(focusedInputRef.current ? focusedInputRef : inputXRef);
        }
    });
    let moveHandler = {
        onMoveStart () {
            currentPosition.current = null;
            stateRef.current.setDragging(true);
        },
        onMove ({ deltaX: deltaX , deltaY: deltaY , pointerType: pointerType , shiftKey: shiftKey  }) {
            let { incrementX: incrementX , decrementX: decrementX , incrementY: incrementY , decrementY: decrementY , xChannelPageStep: xChannelPageStep , xChannelStep: xChannelStep , yChannelPageStep: yChannelPageStep , yChannelStep: yChannelStep , getThumbPosition: getThumbPosition , setColorFromPoint: setColorFromPoint  } = stateRef.current;
            if (currentPosition.current == null) currentPosition.current = getThumbPosition();
            let { width: width , height: height  } = containerRef.current.getBoundingClientRect();
            let valueChanged = deltaX !== 0 || deltaY !== 0;
            if (pointerType === 'keyboard') {
                let deltaXValue = shiftKey && xChannelPageStep > xChannelStep ? xChannelPageStep : xChannelStep;
                let deltaYValue = shiftKey && yChannelPageStep > yChannelStep ? yChannelPageStep : yChannelStep;
                if (deltaX > 0 && direction === 'ltr' || deltaX < 0 && direction === 'rtl') incrementX(deltaXValue);
                else if (deltaX < 0 && direction === 'ltr' || deltaX > 0 && direction === 'rtl') decrementX(deltaXValue);
                else if (deltaY > 0) decrementY(deltaYValue);
                else if (deltaY < 0) incrementY(deltaYValue);
                valueChangedViaKeyboard.current = valueChanged;
                // set the focused input based on which axis has the greater delta
                focusedInputRef.current = valueChanged && Math.abs(deltaY) > Math.abs(deltaX) ? inputYRef.current : inputXRef.current;
            } else {
                currentPosition.current.x += (direction === 'rtl' ? -1 : 1) * deltaX / width;
                currentPosition.current.y += deltaY / height;
                setColorFromPoint(currentPosition.current.x, currentPosition.current.y);
            }
        },
        onMoveEnd () {
            isOnColorArea.current = undefined;
            stateRef.current.setDragging(false);
            focusInput(focusedInputRef.current ? focusedInputRef : inputXRef);
        }
    };
    let { moveProps: movePropsThumb  } = $kZqDi$reactariainteractions.useMove(moveHandler);
    let valueChangedViaKeyboard = $kZqDi$react.useRef(false);
    let { focusWithinProps: focusWithinProps  } = $kZqDi$reactariainteractions.useFocusWithin({
        onFocusWithinChange: (focusWithin)=>{
            if (!focusWithin) {
                valueChangedViaKeyboard.current = false;
                focusedInputRef.current;
            }
        }
    });
    let currentPointer = $kZqDi$react.useRef(undefined);
    let isOnColorArea = $kZqDi$react.useRef(false);
    let { moveProps: movePropsContainer  } = $kZqDi$reactariainteractions.useMove({
        onMoveStart () {
            if (isOnColorArea.current) moveHandler.onMoveStart();
        },
        onMove (e) {
            if (isOnColorArea.current) moveHandler.onMove(e);
        },
        onMoveEnd () {
            if (isOnColorArea.current) moveHandler.onMoveEnd();
        }
    });
    let onThumbDown = (id)=>{
        if (!state.isDragging) {
            currentPointer.current = id;
            valueChangedViaKeyboard.current = false;
            focusInput();
            state.setDragging(true);
            if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onThumbUp, false);
            else {
                addGlobalListener(window, 'mouseup', onThumbUp, false);
                addGlobalListener(window, 'touchend', onThumbUp, false);
            }
        }
    };
    let onThumbUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (id === currentPointer.current) {
            valueChangedViaKeyboard.current = false;
            focusInput();
            state.setDragging(false);
            currentPointer.current = undefined;
            isOnColorArea.current = false;
            if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onThumbUp, false);
            else {
                removeGlobalListener(window, 'mouseup', onThumbUp, false);
                removeGlobalListener(window, 'touchend', onThumbUp, false);
            }
        }
    };
    let onColorAreaDown = (colorArea, id, clientX, clientY)=>{
        let rect = colorArea.getBoundingClientRect();
        let { width: width , height: height  } = rect;
        let x = (clientX - rect.x) / width;
        let y = (clientY - rect.y) / height;
        if (direction === 'rtl') x = 1 - x;
        if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && !state.isDragging && currentPointer.current === undefined) {
            isOnColorArea.current = true;
            valueChangedViaKeyboard.current = false;
            currentPointer.current = id;
            state.setColorFromPoint(x, y);
            focusInput();
            state.setDragging(true);
            if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onColorAreaUp, false);
            else {
                addGlobalListener(window, 'mouseup', onColorAreaUp, false);
                addGlobalListener(window, 'touchend', onColorAreaUp, false);
            }
        }
    };
    let onColorAreaUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (isOnColorArea.current && id === currentPointer.current) {
            isOnColorArea.current = false;
            valueChangedViaKeyboard.current = false;
            currentPointer.current = undefined;
            state.setDragging(false);
            focusInput();
            if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onColorAreaUp, false);
            else {
                removeGlobalListener(window, 'mouseup', onColorAreaUp, false);
                removeGlobalListener(window, 'touchend', onColorAreaUp, false);
            }
        }
    };
    let colorAreaInteractions = isDisabled ? {
    } : $kZqDi$reactariautils.mergeProps({
        ...typeof PointerEvent !== 'undefined' ? {
            onPointerDown: (e)=>{
                if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
                onColorAreaDown(e.currentTarget, e.pointerId, e.clientX, e.clientY);
            }
        } : {
            onMouseDown: (e)=>{
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onColorAreaDown(e.currentTarget, undefined, e.clientX, e.clientY);
            },
            onTouchStart: (e)=>{
                onColorAreaDown(e.currentTarget, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
        }
    }, movePropsContainer);
    let thumbInteractions = isDisabled ? {
    } : $kZqDi$reactariautils.mergeProps({
        ...typeof PointerEvent !== 'undefined' ? {
            onPointerDown: (e)=>{
                if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
                onThumbDown(e.pointerId);
            }
        } : {
            onMouseDown: (e)=>{
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onThumbDown(undefined);
            },
            onTouchStart: (e)=>{
                onThumbDown(e.changedTouches[0].identifier);
            }
        }
    }, focusWithinProps, keyboardProps, movePropsThumb);
    let { focusProps: xInputFocusProps  } = $kZqDi$reactariainteractions.useFocus({
        onFocus: ()=>{
            focusedInputRef.current = inputXRef.current;
        }
    });
    let { focusProps: yInputFocusProps  } = $kZqDi$reactariainteractions.useFocus({
        onFocus: ()=>{
            focusedInputRef.current = inputYRef.current;
        }
    });
    let isMobile = $kZqDi$reactariautils.isIOS() || $kZqDi$reactariautils.isAndroid();
    function getAriaValueTextForChannel(channel) {
        return valueChangedViaKeyboard.current ? stringFormatter.format('colorNameAndValue', {
            name: state.value.getChannelName(channel, locale),
            value: state.value.formatChannelValue(channel, locale)
        }) : [
            stringFormatter.format('colorNameAndValue', {
                name: state.value.getChannelName(channel, locale),
                value: state.value.formatChannelValue(channel, locale)
            }),
            stringFormatter.format('colorNameAndValue', {
                name: state.value.getChannelName(channel === yChannel ? xChannel : yChannel, locale),
                value: state.value.formatChannelValue(channel === yChannel ? xChannel : yChannel, locale)
            })
        ].join(', ');
    }
    let colorPickerLabel = stringFormatter.format('colorPicker');
    let xInputLabellingProps = $kZqDi$reactariautils.useLabels({
        ...props,
        'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {
            label: ariaLabel,
            channelLabel: colorPickerLabel
        }) : colorPickerLabel
    });
    let yInputLabellingProps = $kZqDi$reactariautils.useLabels({
        ...props,
        'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {
            label: ariaLabel,
            channelLabel: colorPickerLabel
        }) : colorPickerLabel
    });
    let colorAreaLabellingProps = $kZqDi$reactariautils.useLabels({
        ...props,
        'aria-label': ariaLabel ? `${ariaLabel}, ${colorPickerLabel}` : undefined
    }, isMobile ? colorPickerLabel : undefined);
    let ariaRoleDescription = stringFormatter.format('twoDimensionalSlider');
    let { visuallyHiddenProps: visuallyHiddenProps  } = $kZqDi$reactariavisuallyhidden.useVisuallyHidden({
        style: {
            opacity: '0.0001',
            width: '100%',
            height: '100%',
            pointerEvents: 'none'
        }
    });
    let { colorAreaStyleProps: colorAreaStyleProps , gradientStyleProps: gradientStyleProps , thumbStyleProps: thumbStyleProps  } = $99936ad0bf67c8c4$export$dd62420467d245ca({
        direction: direction,
        state: state,
        xChannel: xChannel,
        zChannel: zChannel,
        isDisabled: props.isDisabled
    });
    return {
        colorAreaProps: {
            ...colorAreaLabellingProps,
            ...colorAreaInteractions,
            ...colorAreaStyleProps,
            role: 'group'
        },
        gradientProps: {
            ...gradientStyleProps,
            role: 'presentation'
        },
        thumbProps: {
            ...thumbInteractions,
            ...thumbStyleProps,
            role: 'presentation'
        },
        xInputProps: {
            ...xInputLabellingProps,
            ...visuallyHiddenProps,
            ...xInputFocusProps,
            type: 'range',
            min: state.value.getChannelRange(xChannel).minValue,
            max: state.value.getChannelRange(xChannel).maxValue,
            step: xChannelStep1,
            'aria-roledescription': ariaRoleDescription,
            'aria-valuetext': getAriaValueTextForChannel(xChannel),
            disabled: isDisabled,
            value: state.value.getChannelValue(xChannel),
            tabIndex: isMobile || !focusedInputRef.current || focusedInputRef.current === inputXRef.current ? undefined : -1,
            /*
        So that only a single "2d slider" control shows up when listing form elements for screen readers,
        add aria-hidden="true" to the unfocused control when the value has not changed via the keyboard,
        but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.
      */ 'aria-hidden': isMobile || !focusedInputRef.current || focusedInputRef.current === inputXRef.current || valueChangedViaKeyboard.current ? undefined : 'true',
            onChange: (e)=>{
                state.setXValue(parseFloat(e.target.value));
            }
        },
        yInputProps: {
            ...yInputLabellingProps,
            ...visuallyHiddenProps,
            ...yInputFocusProps,
            type: 'range',
            min: state.value.getChannelRange(yChannel).minValue,
            max: state.value.getChannelRange(yChannel).maxValue,
            step: yChannelStep1,
            'aria-roledescription': ariaRoleDescription,
            'aria-valuetext': getAriaValueTextForChannel(yChannel),
            'aria-orientation': 'vertical',
            disabled: isDisabled,
            value: state.value.getChannelValue(yChannel),
            tabIndex: isMobile || focusedInputRef.current && focusedInputRef.current === inputYRef.current ? undefined : -1,
            /*
        So that only a single "2d slider" control shows up when listing form elements for screen readers,
        add aria-hidden="true" to the unfocused input when the value has not changed via the keyboard,
        but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.
      */ 'aria-hidden': isMobile || focusedInputRef.current && focusedInputRef.current === inputYRef.current || valueChangedViaKeyboard.current ? undefined : 'true',
            onChange: (e)=>{
                state.setYValue(parseFloat(e.target.value));
            }
        }
    };
}





function $afbb9647440a7f5b$export$106b7a4e66508f66(props, state) {
    let { trackRef: trackRef , inputRef: inputRef , orientation: orientation , channel: channel , 'aria-label': ariaLabel  } = props;
    let { locale: locale , direction: direction  } = $kZqDi$reactariai18n.useLocale();
    // Provide a default aria-label if there is no other label provided.
    if (!props.label && !ariaLabel && !props['aria-labelledby']) ariaLabel = state.value.getChannelName(channel, locale);
    // @ts-ignore - ignore unused incompatible props
    let { groupProps: groupProps , trackProps: trackProps , labelProps: labelProps , outputProps: outputProps  } = $kZqDi$reactariaslider.useSlider({
        ...props,
        'aria-label': ariaLabel
    }, state, trackRef);
    let { inputProps: inputProps , thumbProps: thumbProps  } = $kZqDi$reactariaslider.useSliderThumb({
        index: 0,
        orientation: orientation,
        isDisabled: props.isDisabled,
        trackRef: trackRef,
        inputRef: inputRef
    }, state);
    let generateBackground = ()=>{
        let value = state.getDisplayColor();
        let to;
        if (orientation === 'vertical') to = 'top';
        else if (direction === 'ltr') to = 'right';
        else to = 'left';
        switch(channel){
            case 'hue':
                return `linear-gradient(to ${to}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
            case 'lightness':
                {
                    // We have to add an extra color stop in the middle so that the hue shows up at all.
                    // Otherwise it will always just be black to white.
                    let min = state.getThumbMinValue(0);
                    let max = state.getThumbMaxValue(0);
                    let start = value.withChannelValue(channel, min).toString('css');
                    let middle = value.withChannelValue(channel, (max - min) / 2).toString('css');
                    let end = value.withChannelValue(channel, max).toString('css');
                    return `linear-gradient(to ${to}, ${start}, ${middle}, ${end})`;
                }
            case 'saturation':
            case 'brightness':
            case 'red':
            case 'green':
            case 'blue':
            case 'alpha':
                {
                    let start = value.withChannelValue(channel, state.getThumbMinValue(0)).toString('css');
                    let end = value.withChannelValue(channel, state.getThumbMaxValue(0)).toString('css');
                    return `linear-gradient(to ${to}, ${start}, ${end})`;
                }
            default:
                throw new Error('Unknown color channel: ' + channel);
        }
    };
    let forcedColorAdjustNoneStyle = {
        forcedColorAdjust: 'none'
    };
    return {
        trackProps: {
            ...$kZqDi$reactariautils.mergeProps(groupProps, trackProps),
            style: {
                ...trackProps.style,
                ...forcedColorAdjustNoneStyle,
                background: generateBackground()
            }
        },
        inputProps: inputProps,
        thumbProps: {
            ...thumbProps,
            style: {
                ...thumbProps.style,
                ...forcedColorAdjustNoneStyle
            }
        },
        labelProps: labelProps,
        outputProps: outputProps
    };
}






function $1d29bf243d4a9a53$export$9064ff4e44b3729a(props, state, inputRef) {
    let { isDisabled: isDisabled , innerRadius: innerRadius , outerRadius: outerRadius , 'aria-label': ariaLabel  } = props;
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $kZqDi$reactariautils.useGlobalListeners();
    let thumbRadius = (innerRadius + outerRadius) / 2;
    let focusInput = $kZqDi$react.useCallback(()=>{
        if (inputRef.current) $kZqDi$reactariautils.focusWithoutScrolling(inputRef.current);
    }, [
        inputRef
    ]);
    let stateRef = $kZqDi$react.useRef(null);
    stateRef.current = state;
    let currentPosition = $kZqDi$react.useRef(null);
    let { keyboardProps: keyboardProps  } = $kZqDi$reactariainteractions.useKeyboard({
        onKeyDown (e) {
            // these are the cases that useMove doesn't handle
            if (!/^(PageUp|PageDown)$/.test(e.key)) {
                e.continuePropagation();
                return;
            }
            // same handling as useMove, don't need to stop propagation, useKeyboard will do that for us
            e.preventDefault();
            // remember to set this and unset it so that onChangeEnd is fired
            stateRef.current.setDragging(true);
            switch(e.key){
                case 'PageUp':
                    e.preventDefault();
                    state.increment(stateRef.current.pageStep);
                    break;
                case 'PageDown':
                    e.preventDefault();
                    state.decrement(stateRef.current.pageStep);
                    break;
            }
            stateRef.current.setDragging(false);
        }
    });
    let moveHandler = {
        onMoveStart () {
            currentPosition.current = null;
            state.setDragging(true);
        },
        onMove ({ deltaX: deltaX , deltaY: deltaY , pointerType: pointerType , shiftKey: shiftKey  }) {
            if (currentPosition.current == null) currentPosition.current = stateRef.current.getThumbPosition(thumbRadius);
            currentPosition.current.x += deltaX;
            currentPosition.current.y += deltaY;
            if (pointerType === 'keyboard') {
                if (deltaX > 0 || deltaY < 0) state.increment(shiftKey ? stateRef.current.pageStep : stateRef.current.step);
                else if (deltaX < 0 || deltaY > 0) state.decrement(shiftKey ? stateRef.current.pageStep : stateRef.current.step);
            } else stateRef.current.setHueFromPoint(currentPosition.current.x, currentPosition.current.y, thumbRadius);
        },
        onMoveEnd () {
            isOnTrack.current = undefined;
            state.setDragging(false);
            focusInput();
        }
    };
    let { moveProps: movePropsThumb  } = $kZqDi$reactariainteractions.useMove(moveHandler);
    let currentPointer = $kZqDi$react.useRef(undefined);
    let isOnTrack = $kZqDi$react.useRef(false);
    let { moveProps: movePropsContainer  } = $kZqDi$reactariainteractions.useMove({
        onMoveStart () {
            if (isOnTrack.current) moveHandler.onMoveStart();
        },
        onMove (e) {
            if (isOnTrack.current) moveHandler.onMove(e);
        },
        onMoveEnd () {
            if (isOnTrack.current) moveHandler.onMoveEnd();
        }
    });
    let onThumbDown = (id)=>{
        if (!state.isDragging) {
            currentPointer.current = id;
            focusInput();
            state.setDragging(true);
            if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onThumbUp, false);
            else {
                addGlobalListener(window, 'mouseup', onThumbUp, false);
                addGlobalListener(window, 'touchend', onThumbUp, false);
            }
        }
    };
    let onThumbUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (id === currentPointer.current) {
            focusInput();
            state.setDragging(false);
            currentPointer.current = undefined;
            isOnTrack.current = false;
            if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onThumbUp, false);
            else {
                removeGlobalListener(window, 'mouseup', onThumbUp, false);
                removeGlobalListener(window, 'touchend', onThumbUp, false);
            }
        }
    };
    let onTrackDown = (track, id, pageX, pageY)=>{
        let rect = track.getBoundingClientRect();
        let x = pageX - rect.x - rect.width / 2;
        let y = pageY - rect.y - rect.height / 2;
        let radius = Math.sqrt(x * x + y * y);
        if (innerRadius < radius && radius < outerRadius && !state.isDragging && currentPointer.current === undefined) {
            isOnTrack.current = true;
            currentPointer.current = id;
            stateRef.current.setHueFromPoint(x, y, radius);
            focusInput();
            state.setDragging(true);
            if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onTrackUp, false);
            else {
                addGlobalListener(window, 'mouseup', onTrackUp, false);
                addGlobalListener(window, 'touchend', onTrackUp, false);
            }
        }
    };
    let onTrackUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (isOnTrack.current && id === currentPointer.current) {
            isOnTrack.current = false;
            currentPointer.current = undefined;
            state.setDragging(false);
            focusInput();
            if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onTrackUp, false);
            else {
                removeGlobalListener(window, 'mouseup', onTrackUp, false);
                removeGlobalListener(window, 'touchend', onTrackUp, false);
            }
        }
    };
    let trackInteractions = isDisabled ? {
    } : $kZqDi$reactariautils.mergeProps({
        ...typeof PointerEvent !== 'undefined' ? {
            onPointerDown: (e)=>{
                if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
                onTrackDown(e.currentTarget, e.pointerId, e.clientX, e.clientY);
            }
        } : {
            onMouseDown: (e)=>{
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onTrackDown(e.currentTarget, undefined, e.clientX, e.clientY);
            },
            onTouchStart: (e)=>{
                onTrackDown(e.currentTarget, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
        }
    }, movePropsContainer);
    let thumbInteractions = isDisabled ? {
    } : $kZqDi$reactariautils.mergeProps({
        onMouseDown: (e)=>{
            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
            onThumbDown(undefined);
        },
        onPointerDown: (e)=>{
            if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
            onThumbDown(e.pointerId);
        },
        onTouchStart: (e)=>{
            onThumbDown(e.changedTouches[0].identifier);
        }
    }, keyboardProps, movePropsThumb);
    let { x: x1 , y: y1  } = state.getThumbPosition(thumbRadius);
    // Provide a default aria-label if none is given
    let { locale: locale  } = $kZqDi$reactariai18n.useLocale();
    if (ariaLabel == null && props['aria-labelledby'] == null) ariaLabel = state.value.getChannelName('hue', locale);
    let inputLabellingProps = $kZqDi$reactariautils.useLabels({
        ...props,
        'aria-label': ariaLabel
    });
    let { minValue: minValue , maxValue: maxValue , step: step  } = state.value.getChannelRange('hue');
    let forcedColorAdjustNoneStyle = {
        forcedColorAdjust: 'none'
    };
    return {
        trackProps: {
            ...trackInteractions,
            style: {
                position: 'relative',
                touchAction: 'none',
                width: outerRadius * 2,
                height: outerRadius * 2,
                background: `
          conic-gradient(
            from 90deg,
            hsl(0, 100%, 50%),
            hsl(30, 100%, 50%),
            hsl(60, 100%, 50%),
            hsl(90, 100%, 50%),
            hsl(120, 100%, 50%),
            hsl(150, 100%, 50%),
            hsl(180, 100%, 50%),
            hsl(210, 100%, 50%),
            hsl(240, 100%, 50%),
            hsl(270, 100%, 50%),
            hsl(300, 100%, 50%),
            hsl(330, 100%, 50%),
            hsl(360, 100%, 50%)
          )
        `,
                clipPath: `path(evenodd, "${$1d29bf243d4a9a53$var$circlePath(outerRadius, outerRadius, outerRadius)} ${$1d29bf243d4a9a53$var$circlePath(outerRadius, outerRadius, innerRadius)}")`,
                ...forcedColorAdjustNoneStyle
            }
        },
        thumbProps: {
            ...thumbInteractions,
            style: {
                position: 'absolute',
                left: '50%',
                top: '50%',
                transform: `translate(calc(${x1}px - 50%), calc(${y1}px - 50%))`,
                touchAction: 'none',
                ...forcedColorAdjustNoneStyle
            }
        },
        inputProps: $kZqDi$reactariautils.mergeProps(inputLabellingProps, {
            type: 'range',
            min: String(minValue),
            max: String(maxValue),
            step: String(step),
            'aria-valuetext': state.value.formatChannelValue('hue', locale),
            disabled: isDisabled,
            value: `${state.value.getChannelValue('hue')}`,
            onChange: (e)=>{
                state.setHue(parseFloat(e.target.value));
            }
        })
    };
}
// Creates an SVG path string for a circle.
function $1d29bf243d4a9a53$var$circlePath(cx, cy, r) {
    return `M ${cx}, ${cy} m ${-r}, 0 a ${r}, ${r}, 0, 1, 0, ${r * 2}, 0 a ${r}, ${r}, 0, 1, 0 ${-r * 2}, 0`;
}







function $58c850037bc7a7ce$export$77e32ca575a28fdf(props, state, ref) {
    let { isDisabled: isDisabled , isReadOnly: isReadOnly , isRequired: isRequired  } = props;
    let { colorValue: colorValue , inputValue: inputValue , commit: commit , increment: increment , decrement: decrement , incrementToMax: incrementToMax , decrementToMin: decrementToMin  } = state;
    let inputId = $kZqDi$reactariautils.useId();
    let { spinButtonProps: spinButtonProps  } = $kZqDi$reactariaspinbutton.useSpinButton({
        isDisabled: isDisabled,
        isReadOnly: isReadOnly,
        isRequired: isRequired,
        maxValue: 16777215,
        minValue: 0,
        onIncrement: increment,
        onIncrementToMax: incrementToMax,
        onDecrement: decrement,
        onDecrementToMin: decrementToMin,
        value: colorValue ? colorValue.toHexInt() : undefined,
        textValue: colorValue ? colorValue.toString('hex') : undefined
    });
    let [focusWithin, setFocusWithin] = $kZqDi$react.useState(false);
    let { focusWithinProps: focusWithinProps  } = $kZqDi$reactariainteractions.useFocusWithin({
        isDisabled: isDisabled,
        onFocusWithinChange: setFocusWithin
    });
    let onWheel = $kZqDi$react.useCallback((e)=>{
        if (Math.abs(e.deltaY) <= Math.abs(e.deltaX)) return;
        if (e.deltaY > 0) increment();
        else if (e.deltaY < 0) decrement();
    }, [
        decrement,
        increment
    ]);
    // If the input isn't supposed to receive input, disable scrolling.
    let scrollingDisabled = isDisabled || isReadOnly || !focusWithin;
    $kZqDi$reactariainteractions.useScrollWheel({
        onScroll: onWheel,
        isDisabled: scrollingDisabled
    }, ref);
    let onChange = (value)=>{
        state.setInputValue(value);
    };
    let { labelProps: labelProps , inputProps: inputProps  } = $kZqDi$reactariatextfield.useFormattedTextField($kZqDi$reactariautils.mergeProps(props, {
        id: inputId,
        value: inputValue,
        defaultValue: undefined,
        type: 'text',
        autoComplete: 'off',
        onChange: onChange
    }), state, ref);
    return {
        labelProps: labelProps,
        inputProps: $kZqDi$reactariautils.mergeProps(inputProps, spinButtonProps, focusWithinProps, {
            role: 'textbox',
            'aria-valuemax': null,
            'aria-valuemin': null,
            'aria-valuenow': null,
            'aria-valuetext': null,
            autoCorrect: 'off',
            spellCheck: 'false',
            onBlur: commit
        })
    };
}




//# sourceMappingURL=main.js.map
