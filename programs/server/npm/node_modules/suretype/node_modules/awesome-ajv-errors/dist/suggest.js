"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.suggestTypedValue = exports.formatBestSuggestion = exports.formatSuggestions = exports.suggest = void 0;
const leven_1 = require("leven");
const types_1 = require("./types");
const style_1 = require("./style");
const util_1 = require("./util");
const defaultLimit = (length) => length < 3 ? 1 : length < 5 ? 2 : 3;
function suggest(value, possibles, opts = {}) {
    if (!possibles)
        return undefined;
    value = `${value}`;
    const { length } = value;
    const { limit = defaultLimit, referenceValue } = opts;
    const distanceLimit = typeof limit === 'number' ? limit : limit(length);
    const suggestions = [];
    const rest = [];
    possibles
        .map(possible => types_1.getTypedValue(possible))
        .map(valueType => ({
        ...valueType,
        distance: valueType.isSimple
            ? leven_1.default(value, `${valueType.value}`)
            : Infinity,
    }))
        .sort((a, b) => a.distance === b.distance ? 0 : a.distance < b.distance ? -1 : 1)
        .forEach(({ distance, type, value, isSimple }) => {
        const suggest = distanceLimit === -1 || distance <= distanceLimit;
        if (suggest)
            suggestions.push({ type, value, isSimple });
        else
            rest.push({ type, value, isSimple });
    });
    // The rest should be alphabetically ordered, it's easier to grasp
    rest.sort((a, b) => `${a.value}`.localeCompare(`${b.value}`));
    const ret = {
        suggestions,
        rest,
        referenceValue,
        best: suggestions === null || suggestions === void 0 ? void 0 : suggestions[0],
    };
    return ret;
}
exports.suggest = suggest;
function formatSuggestions(list, context, opts = {}) {
    var _a, _b, _c;
    if (!list)
        return '';
    const ifSuggestResult = Array.isArray((_a = list) === null || _a === void 0 ? void 0 : _a.rest)
        ? list
        : undefined;
    const rest = (_b = ifSuggestResult === null || ifSuggestResult === void 0 ? void 0 : ifSuggestResult.rest) !== null && _b !== void 0 ? _b : [];
    const suggestions = (_c = ifSuggestResult === null || ifSuggestResult === void 0 ? void 0 : ifSuggestResult.suggestions) !== null && _c !== void 0 ? _c : list;
    const { untyped: defaultUntyped, referenceValue = ifSuggestResult === null || ifSuggestResult === void 0 ? void 0 : ifSuggestResult.referenceValue, isSuggestion, isConst = false, } = opts;
    const referenceType = referenceValue === undefined
        ? undefined
        : types_1.getValueType(referenceValue);
    const useUntyped = () => defaultUntyped !== null && defaultUntyped !== void 0 ? defaultUntyped : false;
    const useType = (suggestion) => referenceValue === undefined
        ? false
        : referenceType !== suggestion.type;
    const formatUntyped = (suggestion) => style_1.formatTypedValue(suggestion, context, {
        untyped: useUntyped(),
        includeType: useType(suggestion),
    });
    const uniqSuggestions = util_1.uniq(suggestions, types_1.getTypedValueKey);
    const allSuggestions = [...uniqSuggestions, ...rest];
    const styledSuggestion = allSuggestions.length === 1
        ? formatUntyped(allSuggestions[0])
        : allSuggestions.length === 2
            ?
                formatUntyped(allSuggestions[0]) +
                    style_1.style.title(" or ", context) +
                    formatUntyped(allSuggestions[1])
            :
                style_1.style.title("any of:", context) + "\n" +
                    style_1.printEnum([
                        ...uniqSuggestions.map(suggestion => formatUntyped(suggestion)),
                        ...(rest.length === 0 ? [] : [
                            "other available values:",
                            ...style_1.printEnum(rest.map(suggestion => formatUntyped(suggestion)), { indent: 2, bullet: false })
                        ])
                    ])
                        .join("\n");
    const isQuestion = allSuggestions.length !== 1 && !isConst;
    return (!isSuggestion ? '' :
        style_1.style.title(`, ${isQuestion ? 'did you mean' : 'it must be'} `, context)) +
        styledSuggestion +
        (isQuestion && isSuggestion && uniqSuggestions.length < 3
            ? style_1.style.title('?', context)
            : '');
}
exports.formatSuggestions = formatSuggestions;
function formatBestSuggestion({ best, referenceValue }, context) {
    if (!best)
        return undefined;
    const includeType = referenceValue === undefined
        ? false
        : types_1.getValueType(referenceValue) !== best.type;
    return style_1.formatTypedValue(best, context, { untyped: false, includeType });
}
exports.formatBestSuggestion = formatBestSuggestion;
function suggestTypedValue(value, types, context) {
    if (typeof value === 'string' && types.includes("number"))
        return {
            type: "number",
            value: style_1.formatTypedValue({ value, type: 'number', isSimple: true }, context),
        };
    else if (typeof value === 'number' && types.includes("string"))
        return {
            type: "string",
            value: style_1.formatTypedValue({ value: `${value}`, type: 'string', isSimple: true }, context),
        };
    else
        return undefined;
}
exports.suggestTypedValue = suggestTypedValue;
