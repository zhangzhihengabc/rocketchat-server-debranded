"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonSchema = exports.getJsonSchemaValidator = exports.ensure = exports.validate = exports.compile = exports.validateSchema = exports.compileSchema = void 0;
const Ajv = require("ajv");
const validation_error_1 = require("./validation-error");
const extract_json_schema_1 = require("./extract-json-schema");
const validation_1 = require("./validation");
const validator_1 = require("./validators/raw/validator");
function validateWrapper(value, validator) {
    const ok = validator(value);
    if (ok)
        return { ok: true };
    const ret = {
        ok: false,
        errors: [...validator.errors],
    };
    return validation_error_1.makeExplanationGetter(ret, 'explanation', ret.errors, validator.schema, value, true);
}
// Compile JSON Schemas and validate data
function compileSchema(schema, opts = {}) {
    const ajv = new Ajv(opts);
    const validator = ajv.compile(schema);
    return function validate(value) {
        return validateWrapper(value, validator);
    };
}
exports.compileSchema = compileSchema;
function validateSchema(schema, value) {
    const validator = compileSchema(schema);
    return validator(value);
}
exports.validateSchema = validateSchema;
function compile(schema, opts = {}) {
    const { ajvOptions = {} } = opts;
    const validator = innerCompile(ajvOptions, schema);
    function validate(value) {
        const res = validateWrapper(value, validator);
        if (!opts.ensure && !opts.simple)
            return res;
        else if (opts.simple)
            return res.ok;
        else if (res.ok)
            return value;
        else
            throw new validation_error_1.ValidationError(res.errors, schema, value);
    }
    return validation_1.attachSchemaToValidator(validate, schema);
}
exports.compile = compile;
function validate(schema, value) {
    const validator = compile(schema);
    return validator(value);
}
exports.validate = validate;
function ensure(schema, value) {
    const validator = compile(schema, { ensure: true });
    return validator(value);
}
exports.ensure = ensure;
function innerCompile(options, validator) {
    const ajv = new Ajv(options);
    const raw = validator_1.getRaw(validator);
    if (raw && raw.fragment) {
        const { fragment } = raw;
        ajv.addSchema(raw.toSchema());
        const validatorFn = ajv.getSchema(`#/definitions/${fragment}`);
        if (!validatorFn)
            throw new ReferenceError(`No such fragment "${fragment}"`);
        return validatorFn;
    }
    else {
        return ajv.compile(extract_json_schema_1.extractSingleJsonSchema(validator).schema);
    }
}
// Compile and validate JSON Schemas themselves
let _jsonSchemaValidator;
function getJsonSchemaValidator() {
    if (!_jsonSchemaValidator) {
        const jsonSchemaSchema = require("ajv/lib/refs/json-schema-draft-07.json");
        _jsonSchemaValidator = compileSchema(jsonSchemaSchema);
    }
    return _jsonSchemaValidator;
}
exports.getJsonSchemaValidator = getJsonSchemaValidator;
function validateJsonSchema(schema) {
    const validator = getJsonSchemaValidator();
    return validator(schema);
}
exports.validateJsonSchema = validateJsonSchema;
