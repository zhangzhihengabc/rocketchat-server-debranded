"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringValidator = void 0;
const validator_1 = require("../value/validator");
const utils_1 = require("../../utils");
const errors_1 = require("../../errors");
class StringValidator extends validator_1.ValueValidator {
    constructor() {
        super(...arguments);
        this.type = "string";
        this._min = undefined;
        this._max = undefined;
        this._pattern = undefined;
        this._format = undefined;
    }
    chainedMinLength() {
        var _a, _b;
        return (_a = this._min) !== null && _a !== void 0 ? _a : (_b = this._parent) === null || _b === void 0 ? void 0 : _b.chainedMinLength();
    }
    chainedMaxLength() {
        var _a, _b;
        return (_a = this._max) !== null && _a !== void 0 ? _a : (_b = this._parent) === null || _b === void 0 ? void 0 : _b.chainedMaxLength();
    }
    chainedPattern() {
        var _a, _b;
        return (_a = this._pattern) !== null && _a !== void 0 ? _a : (_b = this._parent) === null || _b === void 0 ? void 0 : _b.chainedPattern();
    }
    chainedFormat() {
        var _a, _b;
        return (_a = this._format) !== null && _a !== void 0 ? _a : (_b = this._parent) === null || _b === void 0 ? void 0 : _b.chainedFormat();
    }
    const(value) {
        return super.const(value);
    }
    enum(...values) {
        return super.enum(...values);
    }
    minLength(n) {
        if (this.chainedMinLength() !== undefined)
            throw new errors_1.DuplicateConstraintError("minLength");
        const clone = this.clone();
        clone._min = n;
        return clone;
    }
    maxLength(n) {
        if (this.chainedMaxLength() !== undefined)
            throw new errors_1.DuplicateConstraintError("maxLength");
        const clone = this.clone();
        clone._max = n;
        return clone;
    }
    matches(regex) {
        if (this.chainedPattern() !== undefined)
            throw new errors_1.DuplicateConstraintError("matches");
        const clone = this.clone();
        if (typeof regex === "string")
            clone._pattern = regex;
        else
            clone._pattern = regex.source;
        return clone;
    }
    numeric() {
        return this.matches("^(0|-?([1-9][0-9]*)(\.[0-9]+)?)$");
    }
    format(format) {
        if (this.chainedFormat())
            throw new errors_1.DuplicateConstraintError("format");
        const clone = this.clone();
        clone._format = format;
        return clone;
    }
    toSchema(traverser) {
        return {
            type: "string",
            ...this.getJsonSchemaObject(traverser),
            ...utils_1.objectOf(this.chainedMinLength(), "minLength"),
            ...utils_1.objectOf(this.chainedMaxLength(), "maxLength"),
            ...utils_1.objectOf(this.chainedPattern(), "pattern"),
            ...utils_1.objectOf(this.chainedFormat(), "format"),
        };
    }
    clone(clean = false) {
        return this.setupClone(clean, new StringValidator());
    }
}
exports.StringValidator = StringValidator;
