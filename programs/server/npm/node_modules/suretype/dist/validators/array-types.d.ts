import { BaseValidator } from "./base/validator";
import { ArrayValidator } from "./array/validator";
import { TupleValidator } from "./tuple/validator";
import type { TypeOf, IsRequired } from "./functional";
import type { OptionalFrom, Last, Rest, Fill, ReverseRest, Overwrite } from "meta-types";
export declare type FirstOptionalIndex<T extends readonly unknown[], N extends number = T['length']> = T extends [] ? 0 : IsRequired<Last<T>> extends true ? N : FirstOptionalIndex<ReverseRest<T>>;
export declare type ExtractArray<T extends readonly unknown[]> = {
    R: [TypeOf<T[0], true>, ...ExtractArray<Rest<T>>];
    1: [TypeOf<T[0], true>];
    0: [];
}[T['length'] extends 0 ? 0 : T['length'] extends 1 ? 1 : 'R'];
export declare type ArrayOf<T extends readonly unknown[], N extends number = FirstOptionalIndex<T>> = OptionalFrom<ExtractArray<T>, N>;
export declare type ArrayOfWithRest<T extends readonly unknown[], Rest, N extends number = FirstOptionalIndex<T>> = ArrayOfWithRestFilled<Overwrite<Fill<N, Rest>, ExtractArray<T>>, Rest, N>;
declare type ArrayOfWithRestFilled<T extends readonly unknown[], Rest, N extends number> = OptionalFrom<T, N> | [...T, ...Rest[]];
export declare type EnsureArray<T> = T extends Array<infer U> ? T : [T];
export interface TupleFunction {
    <T extends BaseValidator<unknown>[]>(types: [...T]): TupleValidator<ArrayOf<T>, typeof types, FirstOptionalIndex<T>, false>;
}
export declare type ArrayFunction = <U extends BaseValidator<unknown>>(itemType?: U) => ArrayValidator<Array<TypeOf<U>>>;
export {};
