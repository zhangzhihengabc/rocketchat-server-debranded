"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSingleJsonSchema = exports.extractJsonSchema = void 0;
const errors_1 = require("./errors");
const annotations_1 = require("./annotations");
const tree_traverser_1 = require("./tree-traverser");
const validator_1 = require("./validators/raw/validator");
const validation_1 = require("./validation");
/**
 * Get the JSON schema (as a JavaScript object) for an array of schema
 * validators.
 *
 * @param validators The validators to get the JSON schema from.
 */
function extractJsonSchema(validators, { refMethod = 'ref-all', onTopLevelNameConflict = 'error', onNonSuretypeValidator = 'error', } = {}) {
    if (onNonSuretypeValidator === 'ignore') {
        validators = validators.filter(validator => annotations_1.getName(validator));
    }
    else if (onNonSuretypeValidator === 'error') {
        validators.forEach(validator => {
            if (!annotations_1.getName(validator))
                throw new TypeError("Got unnamed validator");
        });
    }
    validators = validation_1.uniqValidators(validators);
    if (onTopLevelNameConflict === 'error') {
        const nameSet = new Set();
        validators
            .map(validator => annotations_1.getNames(validator))
            .filter(v => v.length > 0)
            .forEach(names => {
            for (const name of names) {
                if (nameSet.has(name))
                    throw new errors_1.DuplicateError(`Duplicate validators found with name "${name}"`);
                nameSet.add(name);
            }
        });
    }
    const traverser = new tree_traverser_1.TreeTraverserImpl(validators, refMethod, onNonSuretypeValidator === 'lookup');
    const { schema, lookup } = traverser.getSchema();
    return { schema, lookup };
}
exports.extractJsonSchema = extractJsonSchema;
/**
 * Get the JSON schema (as a JavaScript object) for a single schema validator.
 *
 * @param validator The validator to get the JSON schema from.
 * @returns { schema, fragment } where either schema is a single schema and
 *          fragment is undefined, or schema is a definition schema (with
 *          multiple fragments) and fragment specifies the specific fragment.
 */
function extractSingleJsonSchema(validator) {
    const raw = validator_1.getRaw(validator);
    if (raw)
        return { schema: raw.toSchema(), fragment: raw.fragment };
    const { schema: { definitions } } = extractJsonSchema([validator], {
        refMethod: 'no-refs',
        onNonSuretypeValidator: 'create-name',
        onTopLevelNameConflict: 'rename',
    });
    return { schema: Object.values(definitions)[0] };
}
exports.extractSingleJsonSchema = extractSingleJsonSchema;
