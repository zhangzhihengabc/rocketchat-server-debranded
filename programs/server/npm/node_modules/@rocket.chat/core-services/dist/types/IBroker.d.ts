import type { EventSignatures } from '../Events';
import type { IServiceClass } from './ServiceClass';
export interface IBrokerNode {
    id: string;
    instanceID?: string;
    available: boolean;
    local?: boolean;
}
export type BaseMetricOptions = {
    type: string;
    name: string;
    description?: string;
    labelNames?: Array<string>;
    unit?: string;
    aggregator?: string;
    [key: string]: unknown;
};
export interface IServiceMetrics {
    register(opts: BaseMetricOptions): void;
    hasMetric(name: string): boolean;
    increment(name: string, labels?: Record<string, any>, value?: number, timestamp?: number): void;
    decrement(name: string, labels?: Record<string, any>, value?: number, timestamp?: number): void;
    set(name: string, value: any | null, labels?: Record<string, any>, timestamp?: number): void;
    observe(name: string, value: number, labels?: Record<string, any>, timestamp?: number): void;
    reset(name: string, labels?: Record<string, any>, timestamp?: number): void;
    resetAll(name: string, timestamp?: number): void;
    timer(name: string, labels?: Record<string, any>, timestamp?: number): () => number;
}
export interface IBroker {
    metrics?: IServiceMetrics;
    destroyService(service: IServiceClass): void;
    createService(service: IServiceClass, serviceDependencies?: string[]): void;
    call(method: string, data: any): Promise<any>;
    waitAndCall(method: string, data: any): Promise<any>;
    broadcastToServices<T extends keyof EventSignatures>(services: string[], event: T, ...args: Parameters<EventSignatures[T]>): Promise<void>;
    broadcast<T extends keyof EventSignatures>(event: T, ...args: Parameters<EventSignatures[T]>): Promise<void>;
    broadcastLocal<T extends keyof EventSignatures>(event: T, ...args: Parameters<EventSignatures[T]>): Promise<void>;
    nodeList(): Promise<IBrokerNode[]>;
    start(): Promise<void>;
}
