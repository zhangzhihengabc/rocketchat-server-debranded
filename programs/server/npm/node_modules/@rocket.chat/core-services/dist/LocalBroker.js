"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalBroker = void 0;
const events_1 = require("events");
const models_1 = require("@rocket.chat/models");
const _1 = require(".");
class LocalBroker {
    constructor() {
        this.methods = new Map();
        this.events = new events_1.EventEmitter();
        this.services = new Set();
    }
    async call(method, data) {
        const result = await _1.asyncLocalStorage.run({
            id: 'ctx.id',
            nodeID: 'ctx.nodeID',
            requestID: 'ctx.requestID',
            broker: this,
        }, () => this.methods.get(method)?.(...data));
        return result;
    }
    async waitAndCall(method, data) {
        return this.call(method, data);
    }
    destroyService(instance) {
        const namespace = instance.getName();
        instance.getEvents().forEach((event) => event.listeners.forEach((listener) => this.events.removeListener(event.eventName, listener)));
        const methods = instance.constructor?.name === 'Object'
            ? Object.getOwnPropertyNames(instance)
            : Object.getOwnPropertyNames(Object.getPrototypeOf(instance));
        for (const method of methods) {
            if (method === 'constructor') {
                continue;
            }
            this.methods.delete(`${namespace}.${method}`);
        }
        instance.removeAllListeners();
        instance.stopped();
    }
    createService(instance) {
        const namespace = instance.getName();
        this.services.add(instance);
        instance.created();
        instance.getEvents().forEach((event) => event.listeners.forEach((listener) => this.events.on(event.eventName, listener)));
        const methods = instance.constructor?.name === 'Object'
            ? Object.getOwnPropertyNames(instance)
            : Object.getOwnPropertyNames(Object.getPrototypeOf(instance));
        for (const method of methods) {
            if (method === 'constructor') {
                continue;
            }
            const i = instance;
            this.methods.set(`${namespace}.${method}`, i[method].bind(i));
        }
    }
    onBroadcast(callback) {
        this.events.on('broadcast', callback);
    }
    async broadcast(event, ...args) {
        this.broadcastLocal(event, ...args);
        this.events.emit('broadcast', event, args);
    }
    async broadcastLocal(event, ...args) {
        this.events.emit(event, ...args);
    }
    async broadcastToServices(_services, event, ...args) {
        this.events.emit(event, ...args);
    }
    async nodeList() {
        // TODO models should not be called form here. we should create an abstraction to an internal service to perform this query
        const instances = await models_1.InstanceStatus.find({}, { projection: { _id: 1 } }).toArray();
        return instances.map(({ _id }) => ({ id: _id, available: true }));
    }
    async start() {
        await Promise.all([...this.services].map((service) => service.started()));
    }
}
exports.LocalBroker = LocalBroker;
//# sourceMappingURL=LocalBroker.js.map