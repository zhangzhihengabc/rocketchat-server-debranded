import type { IRoom, IUser } from '@rocket.chat/core-typings';
import type { PaginatedRequest } from '../helpers/PaginatedRequest';
type ShieldSvg = {
    type?: string;
    icon?: 'true' | 'false';
    channel: string;
    name: string;
    userId?: string;
    username?: string;
    user?: string;
};
export declare const isShieldSvgProps: import("ajv").ValidateFunction<ShieldSvg>;
type Spotlight = {
    query: string;
};
export declare const isSpotlightProps: import("ajv").ValidateFunction<Spotlight>;
type Directory = PaginatedRequest<{
    text: string;
    type: string;
    workspace: string;
}>;
export declare const isDirectoryProps: import("ajv").ValidateFunction<Directory>;
type MethodCall = {
    method: string;
    params: unknown[];
    id: string;
    msg: 'string';
};
export declare const isMethodCallProps: import("ajv").ValidateFunction<MethodCall>;
export declare const isMeteorCall: import("ajv").ValidateFunction<{
    message: string;
}>;
type MethodCallAnon = {
    method: string;
    params: unknown[];
    id: string;
    msg: 'method';
};
export declare const isMethodCallAnonProps: import("ajv").ValidateFunction<MethodCallAnon>;
type Fingerprint = {
    setDeploymentAs: 'new-workspace' | 'updated-configuration';
};
export declare const isFingerprintProps: import("ajv").ValidateFunction<Fingerprint>;
type PwGetPolicyReset = {
    token: string;
};
export declare const validateParamsPwGetPolicyRest: import("ajv").ValidateFunction<PwGetPolicyReset>;
export type MiscEndpoints = {
    '/v1/stdout.queue': {
        GET: () => {
            queue: {
                id: string;
                string: string;
                ts: Date;
            }[];
        };
    };
    '/v1/shield.svg': {
        GET: (params: ShieldSvg) => {
            svg: string;
        };
    };
    '/v1/spotlight': {
        GET: (params: Spotlight) => {
            users: Pick<Required<IUser>, 'name' | 'status' | 'statusText' | 'avatarETag' | '_id' | 'username'>[];
            rooms: Pick<Required<IRoom>, 't' | 'name' | 'lastMessage' | '_id'>[];
        };
    };
    '/v1/pw.getPolicy': {
        GET: () => {
            enabled: boolean;
            policy: [name: string, value?: Record<string, number>][];
        };
    };
    '/v1/pw.getPolicyReset': {
        GET: (params: PwGetPolicyReset) => {
            enabled: boolean;
            policy: [name: string, options?: Record<string, unknown>][];
        };
    };
    '/v1/method.call/:method': {
        POST: (params: {
            message: string;
        }) => {
            message: unknown;
        };
    };
    '/v1/method.callAnon/:method': {
        POST: (params: {
            message: string;
        }) => {
            message: unknown;
        };
    };
    '/v1/fingerprint': {
        POST: (params: Fingerprint) => {
            success: boolean;
        };
    };
    '/v1/smtp.check': {
        GET: () => {
            isSMTPConfigured: boolean;
        };
    };
};
export {};
//# sourceMappingURL=misc.d.ts.map