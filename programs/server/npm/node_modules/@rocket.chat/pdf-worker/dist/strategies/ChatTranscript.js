"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatTranscript = void 0;
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const ChatTranscript_1 = __importDefault(require("../templates/ChatTranscript"));
class ChatTranscript {
    constructor() {
        this.isChatTranscriptData = (data) => {
            return ('header' in data &&
                'messages' in data &&
                't' in data &&
                'agent' in data.header &&
                'visitor' in data.header &&
                'siteName' in data.header &&
                'date' in data.header &&
                'time' in data.header);
        };
    }
    isNewDay(current, previous, timezone) {
        return !previous || !(0, moment_timezone_1.default)(current.ts).tz(timezone).isSame(previous.ts, 'day');
    }
    parserMessages(messages, dateFormat, timeAndDateFormat, timezone) {
        return messages.map((message, index, arr) => {
            const previousMessage = arr[index - 1];
            const { ts, ...rest } = message;
            const formattedTs = (0, moment_timezone_1.default)(ts).tz(timezone).format(timeAndDateFormat);
            const isDivider = this.isNewDay(message, previousMessage, timezone);
            const formattedQuotes = message.quotes?.length
                ? message.quotes.map((quote) => {
                    return {
                        ...quote,
                        ts: (0, moment_timezone_1.default)(quote.ts).tz(timezone).format(timeAndDateFormat),
                    };
                })
                : undefined;
            if (isDivider) {
                return {
                    ...rest,
                    ts: formattedTs,
                    divider: (0, moment_timezone_1.default)(ts).tz(timezone).format(dateFormat),
                    quotes: formattedQuotes,
                };
            }
            return {
                ...rest,
                ts: formattedTs,
                quotes: formattedQuotes,
            };
        });
    }
    getTranslations(translations) {
        return (key) => {
            const translation = translations.find((t) => t.key === key);
            if (!translation) {
                throw new Error(`Translation not found for key: ${key}`);
            }
            return translation.value;
        };
    }
    renderTemplate(data) {
        if (!this.isChatTranscriptData(data)) {
            throw new Error('Invalid data');
        }
        return (0, ChatTranscript_1.default)(data);
    }
    parseTemplateData(data) {
        return {
            header: {
                visitor: data.visitor,
                agent: data.agent,
                siteName: data.siteName,
                date: `${(0, moment_timezone_1.default)(data.closedAt)
                    .tz(data.timezone)
                    .format(String(data.dateFormat))}`,
                time: `${(0, moment_timezone_1.default)(data.closedAt)
                    .tz(data.timezone)
                    .format('H:mm:ss')} ${data.timezone}`,
            },
            messages: Array.isArray(data.messages)
                ? this.parserMessages(data.messages, data.dateFormat, data.timeAndDateFormat, data.timezone)
                : [],
            t: this.getTranslations(data.translations),
        };
    }
}
exports.ChatTranscript = ChatTranscript;
//# sourceMappingURL=ChatTranscript.js.map