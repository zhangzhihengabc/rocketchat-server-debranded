"use strict";
// Copyright 2021 The Matrix.org Foundation C.I.C.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OlmMachine = void 0;
const napi_1 = require("./napi");
const utils_1 = require("./utils");
// Manually imported type
var RequestKind;
(function (RequestKind) {
    RequestKind[RequestKind["KeysUpload"] = 1] = "KeysUpload";
    RequestKind[RequestKind["KeysQuery"] = 2] = "KeysQuery";
    RequestKind[RequestKind["ToDevice"] = 3] = "ToDevice";
    RequestKind[RequestKind["SignatureUpload"] = 4] = "SignatureUpload";
    RequestKind[RequestKind["RoomMessage"] = 5] = "RoomMessage";
    RequestKind[RequestKind["KeysClaim"] = 6] = "KeysClaim";
    RequestKind[RequestKind["KeysBackup"] = 7] = "KeysBackup";
})(RequestKind || (RequestKind = {}));
// Dev note: Due to complexities in the types structure, we can't reliably pull in the types for the
// napi-module. Be careful with your implementation!
class OlmMachine {
    constructor(_userId, _deviceId, engine) {
        this._userId = _userId;
        this._deviceId = _deviceId;
        this.engine = engine;
    }
    makeSled(dir) {
        this.machine = new napi_1.default.SledBackedOlmMachine(this._userId, this._deviceId, dir);
        return this;
    }
    static withSledBackend(userId, deviceId, engine, sledPath) {
        return (new OlmMachine(userId, deviceId, engine)).makeSled(sledPath);
    }
    async runEngine() {
        const requests = (0, utils_1.toArray)(this.machine.outgoingRequests ?? []).map((r) => JSON.parse(r));
        for (const request of requests) {
            await this.runEngineRequest(request);
        }
    }
    async runEngineRequest(request) {
        switch (request['request_kind']) {
            case 'KeysUpload': {
                const resp = await this.engine.uploadOneTimeKeys(request['body']);
                this.machine.markRequestAsSent(request['request_id'], RequestKind.KeysUpload, JSON.stringify(resp));
                break;
            }
            case 'KeysQuery': {
                const userIds = Array.isArray(request['users']) ? request['users'] : [request['users']];
                const resp = await this.engine.queryOneTimeKeys(userIds);
                this.machine.markRequestAsSent(request['request_id'], RequestKind.KeysQuery, JSON.stringify(resp));
                break;
            }
            case 'KeysClaim': {
                const resp = await this.engine.claimOneTimeKeys(request['one_time_keys']);
                this.machine.markRequestAsSent(request['request_id'], RequestKind.KeysClaim, JSON.stringify(resp));
                break;
            }
            case 'ToDevice': {
                await this.engine.sendToDevices(request['event_type'], request['body']);
                break;
            }
            default:
                // TODO: Handle properly
                console.error("Unhandled request:", request);
                break;
        }
    }
    // --- proxy interface below here ---
    get userId() {
        return this.machine.userId;
    }
    get deviceId() {
        return this.machine.deviceId;
    }
    get deviceDisplayName() {
        return this.machine.deviceDisplayName;
    }
    get identityKeys() {
        return this.machine.identityKeys;
    }
    getDevice(userId, deviceId) {
        return this.machine.getDevice(userId, deviceId);
    }
    getUserDevices(userId) {
        return this.machine.getUserDevices(userId);
    }
    async pushSync(events, deviceLists, remainingKeyCounts, unusedFallbackKeyTypes) {
        const keyCounts = Object.entries(remainingKeyCounts).map(e => [e[0], e[1].toString()]).reduce((c, p) => ({ ...c, [p[0]]: p[1] }), {});
        this.machine.receiveSyncChanges(JSON.stringify({ events }), deviceLists, keyCounts, unusedFallbackKeyTypes);
        await this.runEngine();
    }
    /**
     * Adds users to the tracked user list. `runEngine()` should be
     * called after this, though can be delayed until all updates have
     * been made.
     * @param {string[]} userIds The user IDs to add.
     * @returns {Promise<void>} Resolves when complete.
     */
    async updateTrackedUsers(userIds) {
        this.machine.updateTrackedUsers(userIds);
    }
    isUserTracked(userId) {
        return this.machine.isUserTracked(userId);
    }
    async ensureSessionsFor(userIds) {
        const request = JSON.parse(this.machine.getMissingSessions(userIds));
        if (request['request_kind']) {
            await this.runEngineRequest(request);
        }
    }
    // TODO: Need to lock based on room ID
    async encryptRoomEvent(roomId, eventType, content) {
        const userIds = await this.engine.getEffectiveJoinedUsersInRoom(roomId);
        this.machine.updateTrackedUsers(userIds);
        await this.runEngine();
        await this.ensureSessionsFor(userIds); // runs the relevant parts of the engine internally
        const requests = (0, utils_1.toArray)(this.machine.shareRoomKey(roomId, userIds)).map(k => JSON.parse(k));
        for (const request of requests) {
            await this.runEngineRequest(request);
        }
        await this.runEngine();
        return JSON.parse(this.machine.encrypt(roomId, eventType, JSON.stringify(content)));
    }
    async decryptRoomEvent(roomId, event) {
        const parsed = this.machine.decryptRoomEvent(JSON.stringify(event), roomId);
        parsed.clearEvent = JSON.parse(parsed.clearEvent);
        await this.runEngine();
        return parsed;
    }
    async sign(message) {
        return JSON.parse(this.machine.sign(JSON.stringify(message)));
    }
}
exports.OlmMachine = OlmMachine;
//# sourceMappingURL=OlmMachine.js.map