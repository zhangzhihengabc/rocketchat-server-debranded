import { Device, DeviceLists } from "./napi-module";
export declare type Optional<T> = T | null | undefined;
export interface MatrixEvent {
    event_id: string;
    room_id: string;
    type: string;
    sender: string;
    content: Record<string, any>;
    origin_server_ts: number;
    unsigned: Record<string, any>;
}
export interface ToDeviceEvent {
    type: string;
    sender: string;
    content: Record<string, any>;
}
export interface DecryptedMatrixEvent {
    clearEvent: MatrixEvent;
    senderCurve25519Key: string;
    claimedEd25519Key?: Optional<string>;
    forwardingCurve25519Chain: string[];
}
export interface GenericKeys {
    [keyId: string]: string;
}
export interface Signatures {
    [entity: string]: {
        [keyId: string]: string;
    };
}
export interface DeviceKeys {
    algorithms: string[];
    device_id: string;
    keys: GenericKeys;
    signatures: Signatures;
    user_id: string;
}
export interface FallbackKey {
    key: string;
    fallback: true;
    signatures: Signatures;
}
export interface OTKCounts {
    one_time_key_counts: {
        [algorithm: string]: number;
    };
    fallback_keys?: {
        [algorithm: string]: FallbackKey;
    };
    ["org.matrix.msc2732.fallback_keys"]?: {
        [algorithm: string]: FallbackKey;
    };
}
export interface KeyClaim {
    [userId: string]: {
        [deviceId: string]: string;
    };
}
export interface KeyClaimResponse {
    one_time_keys: {
        [userId: string]: {
            [deviceId: string]: {
                [algorithm: string]: string | {
                    key: string;
                    signatures: Signatures;
                };
            };
        };
    };
    failures?: {
        [serverName: string]: Record<string, any>;
    };
}
export interface KeyQueryResults {
    device_keys: {
        [userId: string]: {
            [deviceId: string]: {
                algorithms: string[];
                device_id: string;
                keys: {
                    [keyId: string]: string;
                };
                signatures: Signatures;
                unsigned?: Record<string, any>;
                user_id: string;
            };
        };
    };
    master_keys?: {
        [userId: string]: {
            keys: {
                [keyId: string]: string;
            };
            usage: string[];
            user_id: string;
        };
    };
    self_signing_keys?: {
        [user_id: string]: {
            keys: {
                [keyId: string]: string;
            };
            signatures: Signatures;
            usage: string[];
            user_id: string;
        };
    };
    user_signing_keys?: {
        [user_id: string]: {
            keys: {
                [keyId: string]: string;
            };
            signatures: Signatures;
            usage: string[];
            user_id: string;
        };
    };
    failures?: {
        [serverName: string]: Record<string, any>;
    };
}
export interface ToDeviceMessages {
    [userId: string]: {
        [deviceId: string]: any;
    };
}
export interface OlmEngine {
    uploadOneTimeKeys(body: {
        device_keys?: DeviceKeys;
        one_time_keys?: GenericKeys;
    }): Promise<OTKCounts>;
    queryOneTimeKeys(userIds: string[]): Promise<KeyQueryResults>;
    claimOneTimeKeys(claim: KeyClaim): Promise<KeyClaimResponse>;
    sendToDevices(eventType: string, messages: ToDeviceMessages): Promise<void>;
    getEffectiveJoinedUsersInRoom(roomId: string): Promise<string[]>;
}
export declare class OlmMachine {
    private _userId;
    private _deviceId;
    private engine;
    private machine;
    private constructor();
    private makeSled;
    static withSledBackend(userId: string, deviceId: string, engine: OlmEngine, sledPath: string): OlmMachine;
    runEngine(): Promise<void>;
    private runEngineRequest;
    get userId(): string;
    get deviceId(): string;
    get deviceDisplayName(): Optional<string>;
    get identityKeys(): Record<string, string>;
    getDevice(userId: string, deviceId: string): Optional<Device>;
    getUserDevices(userId: string): Device[];
    pushSync(events: ToDeviceEvent[], deviceLists: DeviceLists, remainingKeyCounts: Record<string, number>, unusedFallbackKeyTypes?: string[]): Promise<void>;
    /**
     * Adds users to the tracked user list. `runEngine()` should be
     * called after this, though can be delayed until all updates have
     * been made.
     * @param {string[]} userIds The user IDs to add.
     * @returns {Promise<void>} Resolves when complete.
     */
    updateTrackedUsers(userIds: string[]): Promise<void>;
    isUserTracked(userId: string): boolean;
    ensureSessionsFor(userIds: string[]): Promise<void>;
    encryptRoomEvent(roomId: string, eventType: string, content: Record<string, any>): Promise<Record<string, any>>;
    decryptRoomEvent(roomId: string, event: MatrixEvent): Promise<DecryptedMatrixEvent>;
    sign(message: Record<string, any>): Promise<Signatures>;
}
