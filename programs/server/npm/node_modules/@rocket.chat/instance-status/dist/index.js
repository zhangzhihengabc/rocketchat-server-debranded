"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstanceStatus = void 0;
// import { IInstanceStatus } from '@rocket.chat/core-typings';
const events_1 = require("events");
const models_1 = require("@rocket.chat/models");
const uuid_1 = require("uuid");
const events = new events_1.EventEmitter();
const defaultPingInterval = parseInt(String(process.env.MULTIPLE_INSTANCES_PING_INTERVAL)) || 10; // default to 10s
// if not set via env var ensures at least 3 ticks before expiring (multiple of 60s)
const indexExpire = (parseInt(String(process.env.MULTIPLE_INSTANCES_EXPIRE)) || Math.ceil((defaultPingInterval * 3) / 60)) * 60;
let createIndexes = async () => {
    await models_1.InstanceStatus.col
        .indexes()
        .catch(function () {
        // the collection should not exists yet, return empty then
        return [];
    })
        .then(function (result) {
        return result.some(function (index) {
            if (index.key && index.key._updatedAt === 1) {
                if (index.expireAfterSeconds !== indexExpire) {
                    models_1.InstanceStatus.col.dropIndex(index.name);
                    return false;
                }
                return true;
            }
            return false;
        });
    })
        .then(function (created) {
        if (!created) {
            models_1.InstanceStatus.col.createIndex({ _updatedAt: 1 }, { expireAfterSeconds: indexExpire });
        }
    });
    createIndexes = async () => {
        // no op
    };
};
const ID = (0, uuid_1.v4)();
function id() {
    return ID;
}
const currentInstance = {
    name: '',
    extraInformation: {},
};
async function registerInstance(name, extraInformation) {
    createIndexes();
    currentInstance.name = name;
    currentInstance.extraInformation = extraInformation;
    // if (ID === undefined || ID === null) {
    // 	return console.error('[multiple-instances-status] only can be called after Meteor.startup');
    // }
    const instance = {
        $set: {
            pid: process.pid,
            name,
            ...(extraInformation && { extraInformation }),
        },
        $currentDate: {
            _createdAt: true,
            _updatedAt: true,
        },
    };
    try {
        await models_1.InstanceStatus.updateOne({ _id: ID }, instance, { upsert: true });
        const result = await models_1.InstanceStatus.findOne({ _id: ID });
        start();
        events.emit('registerInstance', result, instance);
        process.on('exit', onExit);
        return result;
    }
    catch (e) {
        return e;
    }
}
async function unregisterInstance() {
    try {
        const result = await models_1.InstanceStatus.deleteOne({ _id: ID });
        stop();
        events.emit('unregisterInstance', ID);
        process.removeListener('exit', onExit);
        return result;
    }
    catch (e) {
        return e;
    }
}
let pingInterval;
function start(interval) {
    stop();
    interval = interval || defaultPingInterval;
    pingInterval = setInterval(function () {
        ping();
    }, interval * 1000);
}
function stop() {
    if (!pingInterval) {
        return;
    }
    clearInterval(pingInterval);
    pingInterval = null;
}
async function ping() {
    const result = await models_1.InstanceStatus.updateOne({
        _id: ID,
    }, {
        $currentDate: {
            _updatedAt: true,
        },
    });
    if (result.modifiedCount === 0) {
        await registerInstance(currentInstance.name, currentInstance.extraInformation);
    }
}
async function onExit() {
    await unregisterInstance();
}
async function updateConnections(conns) {
    await models_1.InstanceStatus.updateOne({
        _id: ID,
    }, {
        $set: {
            'extraInformation.conns': conns,
        },
    });
}
exports.InstanceStatus = {
    id,
    registerInstance,
    updateConnections,
};
//# sourceMappingURL=index.js.map