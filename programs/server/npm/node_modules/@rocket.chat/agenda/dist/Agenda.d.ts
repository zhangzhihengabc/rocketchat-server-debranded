/// <reference types="node" />
import { EventEmitter } from 'events';
import type { MongoClientOptions, Db } from 'mongodb';
import { Job } from './Job';
import type { IJob } from './definition/IJob';
import type { JobDefinition } from './definition/JobDefinition';
type JobSort = Partial<Record<keyof IJob, 1 | -1>>;
type AgendaConfig = {
    name?: string;
    processEvery?: string;
    defaultConcurrency?: number;
    maxConcurrency?: number;
    defaultLockLimit?: number;
    lockLimit?: number;
    defaultLockLifeTime?: number;
    sort?: JobSort;
} & ({
    mongo: Db;
    db?: {
        collection?: string;
    };
} | {
    mongo?: undefined;
    db?: {
        address: string;
        collection?: string;
        options?: MongoClientOptions;
    };
});
type AgendaCallback = (error: unknown, result: unknown) => void;
export type RepeatOptions = {
    timezone?: string;
    skipImmediate?: boolean;
};
export declare class Agenda extends EventEmitter {
    private _name;
    private _processEvery;
    private _defaultConcurrency;
    private _maxConcurrency;
    private _defaultLockLimit;
    private _defaultLockLifetime;
    private _db;
    private _mdb;
    private _collection;
    private _definitions;
    private _runningJobs;
    private _lockedJobs;
    private _jobsToLock;
    private _jobQueue;
    private _lockLimit;
    private _sort;
    private _indexes;
    private _isLockingOnTheFly;
    private _ready;
    private _processInterval;
    private _nextScanAt?;
    private _mongoUseUnifiedTopology;
    constructor(config?: AgendaConfig, cb?: AgendaCallback);
    mongo(mdb: Db, collection: string | undefined, cb?: AgendaCallback): Agenda;
    /**
     * * NOTE:
     * If `url` includes auth details then `options` must specify: { 'uri_decode_auth': true }. This does Auth on
     * the specified database, not the Admin database. If you are using Auth on the Admin DB and not on the Agenda DB,
     * then you need to authenticate against the Admin DB and then pass the MongoDB instance into the constructor
     * or use Agenda.mongo(). If your app already has a MongoDB connection then use that. ie. specify config.mongo in
     * the constructor or use Agenda.mongo().
     */
    database(url: string, collection: string | undefined, options?: MongoClientOptions, cb?: AgendaCallback): Agenda;
    dbInit(collection: string | undefined, cb?: AgendaCallback): void;
    name(name: string): Agenda;
    processEvery(time: string): Agenda;
    maxConcurrency(num: number): Agenda;
    defaultConcurrency(num: number): Agenda;
    lockLimit(num: number): Agenda;
    defaultLockLimit(num: number): Agenda;
    defaultLockLifetime(ms: number): Agenda;
    sort(query: JobSort): Agenda;
    create(name: string, data?: IJob['data']): Job;
    jobs(query?: {}, sort?: {}, limit?: number, skip?: number): Promise<Job[]>;
    purge(): Promise<unknown>;
    define(name: string, processor: JobDefinition['fn']): void;
    every(interval: string | number, name: string, data: IJob['data'], options: RepeatOptions): Promise<Job>;
    every(interval: string | number, names: string[], data: IJob['data'], options: RepeatOptions): Promise<Job[]>;
    _createIntervalJob(interval: string | number, name: string, data: IJob['data'], options: RepeatOptions): Promise<Job>;
    private _createIntervalJobs;
    private _createScheduledJob;
    private _createScheduledJobs;
    schedule(when: string | Date, name: string, data: IJob['data']): Promise<Job>;
    schedule(when: string | Date, names: string[], data: IJob['data']): Promise<Job[]>;
    now(name: string, data: IJob['data'], ...args: Array<any>): Promise<Job>;
    cancel(query: Record<string, any>): Promise<number>;
    has(query: Record<string, any>): Promise<boolean>;
    private _processDbResult;
    private _updateJob;
    private _saveSingleJob;
    private _saveUniqueJob;
    private _saveNewJob;
    saveJob(job: Job): Promise<void>;
    start(): Promise<void>;
    private _unlockJobs;
    stop(): Promise<void>;
    getDefinition(jobName: string): JobDefinition;
    private _findAndLockNextJob;
    /**
     * Returns true if a job of the specified name can be locked.
     * Considers maximum locked jobs at any time if self._lockLimit is > 0
     * Considers maximum locked jobs of the specified name at any time if jobDefinition.lockLimit is > 0
     */
    private _shouldLock;
    private _enqueueJobs;
    /**
     * Internal method that will lock a job and store it on MongoDB
     * This method is called when we immediately start to process a job without using the process interval
     * We do this because sometimes jobs are scheduled but will be run before the next process time
     */
    private _lockOnTheFly;
    private _jobQueueFilling;
    private _runOrRetry;
    private _jobProcessing;
    private _processJobResult;
    processJobs(extraJob?: Job): void;
}
export {};
