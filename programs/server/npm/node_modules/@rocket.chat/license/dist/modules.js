"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceModules = exports.hasModule = exports.getModules = exports.invalidateAll = exports.notifyInvalidatedModules = exports.notifyValidatedModules = void 0;
const emitter_1 = require("./events/emitter");
function notifyValidatedModules(licenseModules) {
    licenseModules.forEach((module) => {
        this.modules.add(module);
        emitter_1.moduleValidated.call(this, module);
    });
}
exports.notifyValidatedModules = notifyValidatedModules;
function notifyInvalidatedModules(licenseModules) {
    licenseModules.forEach((module) => {
        emitter_1.moduleRemoved.call(this, module);
        this.modules.delete(module);
    });
}
exports.notifyInvalidatedModules = notifyInvalidatedModules;
function invalidateAll() {
    notifyInvalidatedModules.call(this, [...this.modules]);
    this.modules.clear();
}
exports.invalidateAll = invalidateAll;
function getModules() {
    return [...this.modules];
}
exports.getModules = getModules;
function hasModule(module) {
    return this.modules.has(module);
}
exports.hasModule = hasModule;
function replaceModules(newModules) {
    let anyChange = false;
    for (const moduleName of newModules) {
        if (this.modules.has(moduleName)) {
            continue;
        }
        this.modules.add(moduleName);
        emitter_1.moduleValidated.call(this, moduleName);
        anyChange = true;
    }
    for (const moduleName of this.modules) {
        if (newModules.includes(moduleName)) {
            continue;
        }
        emitter_1.moduleRemoved.call(this, moduleName);
        this.modules.delete(moduleName);
        anyChange = true;
    }
    return anyChange;
}
exports.replaceModules = replaceModules;
//# sourceMappingURL=modules.js.map