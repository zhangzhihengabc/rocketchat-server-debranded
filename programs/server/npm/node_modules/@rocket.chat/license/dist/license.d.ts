import type { ILicenseTag, LicenseEvents, ILicenseV2, ILicenseV3, LicenseLimitKind, LicenseInfo, LicenseModule, LicenseValidationOptions, LimitContext } from '@rocket.chat/core-typings';
import { Emitter } from '@rocket.chat/emitter';
export declare class LicenseManager extends Emitter<LicenseEvents> {
    dataCounters: Map<"activeUsers" | "guestUsers" | "roomsPerGuest" | "privateApps" | "marketplaceApps" | "monthlyActiveContacts", (context?: LimitContext<LicenseLimitKind>) => Promise<number>>;
    pendingLicense: string;
    tags: Set<ILicenseTag>;
    modules: Set<LicenseModule>;
    private workspaceUrl;
    protected _license: ILicenseV3 | undefined;
    private _unmodifiedLicense;
    private _valid;
    protected _lockedLicense: string | undefined;
    private states;
    get shouldPreventActionResults(): Map<"activeUsers" | "guestUsers" | "roomsPerGuest" | "privateApps" | "marketplaceApps" | "monthlyActiveContacts", boolean>;
    get license(): ILicenseV3 | undefined;
    get unmodifiedLicense(): ILicenseV2 | ILicenseV3 | undefined;
    get valid(): boolean | undefined;
    get encryptedLicense(): string | undefined;
    setWorkspaceUrl(url: string): Promise<void>;
    getWorkspaceUrl(): string | undefined;
    revalidateLicense(options?: Omit<LicenseValidationOptions, 'isNewLicense'>): Promise<void>;
    /**
     * The sync method should be called when a license from a different instance is has changed, so the local instance
     * needs to be updated. This method will validate the license and update the local instance if the license is valid, but will not trigger the onSync event.
     */
    sync(options?: Omit<LicenseValidationOptions, 'isNewLicense'>): Promise<void>;
    private clearLicenseData;
    private invalidateLicense;
    remove(): void;
    private setLicenseV3;
    private setLicenseV2;
    private isLicenseDuplicated;
    private validateLicense;
    setLicense(encryptedLicense: string, isNewLicense?: boolean): Promise<boolean>;
    private triggerBehaviorEvents;
    private triggerBehaviorEventsToggled;
    hasValidLicense(): boolean;
    getLicense(): ILicenseV3 | undefined;
    syncShouldPreventActionResults(actions: Record<LicenseLimitKind, boolean>): void;
    shouldPreventActionResultsMap(): Promise<{
        [key in LicenseLimitKind]: boolean;
    }>;
    shouldPreventAction<T extends LicenseLimitKind>(action: T, extraCount?: number, context?: Partial<LimitContext<T>>, { suppressLog }?: Pick<LicenseValidationOptions, 'suppressLog'>): Promise<boolean>;
    private consolidateBehaviorState;
    getInfo({ limits: includeLimits, currentValues: loadCurrentValues, license: includeLicense, }: {
        limits: boolean;
        currentValues: boolean;
        license: boolean;
    }): Promise<LicenseInfo>;
}
