"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OmnichannelTranscript = void 0;
const core_services_1 = require("@rocket.chat/core-services");
const core_typings_1 = require("@rocket.chat/core-typings");
const message_parser_1 = require("@rocket.chat/message-parser");
const models_1 = require("@rocket.chat/models");
const pdf_worker_1 = require("@rocket.chat/pdf-worker");
const tools_1 = require("@rocket.chat/tools");
const isPromiseRejectedResult = (result) => result.status === 'rejected';
class OmnichannelTranscript extends core_services_1.ServiceClass {
    constructor(loggerClass) {
        super();
        this.name = 'omnichannel-transcript';
        this.maxNumberOfConcurrentJobs = 25;
        this.currentJobNumber = 0;
        this.worker = new pdf_worker_1.PdfWorker('chat-transcript');
        // eslint-disable-next-line new-cap
        this.log = new loggerClass('OmnichannelTranscript');
    }
    async getTimezone(user) {
        const reportingTimezone = await core_services_1.Settings.get('Default_Timezone_For_Reporting');
        switch (reportingTimezone) {
            case 'custom':
                return core_services_1.Settings.get('Default_Custom_Timezone');
            case 'user':
                if (user?.utcOffset) {
                    return (0, tools_1.guessTimezoneFromOffset)(user.utcOffset);
                }
                return (0, tools_1.guessTimezone)();
            default:
                return (0, tools_1.guessTimezone)();
        }
    }
    getMessagesFromRoom({ rid }) {
        // Closing message should not appear :)
        return models_1.Messages.findLivechatMessagesWithoutClosing(rid, {
            sort: { ts: 1 },
            projection: { _id: 1, msg: 1, u: 1, t: 1, ts: 1, attachments: 1, files: 1, md: 1 },
        }).toArray();
    }
    async requestTranscript({ details }) {
        this.log.info(`Requesting transcript for room ${details.rid} by user ${details.userId}`);
        const room = await models_1.LivechatRooms.findOneById(details.rid);
        if (!room) {
            throw new Error('room-not-found');
        }
        if (room.open) {
            throw new Error('room-still-open');
        }
        if (!room.v) {
            throw new Error('improper-room-state');
        }
        // Don't request a transcript if there's already one requested :)
        if (room.pdfTranscriptRequested) {
            // TODO: use logger
            this.log.info(`Transcript already requested for room ${details.rid}`);
            return;
        }
        await models_1.LivechatRooms.setTranscriptRequestedPdfById(details.rid);
        // Make the whole process sync when running on test mode
        // This will prevent the usage of timeouts on the tests of this functionality :)
        if (process.env.TEST_MODE) {
            await this.workOnPdf({ details: { ...details, from: this.name } });
            return;
        }
        // Even when processing is done "in-house", we still need to queue the work
        // to avoid blocking the request
        this.log.info(`Queuing work for room ${details.rid}`);
        await core_services_1.QueueWorker.queueWork('work', `${this.name}.workOnPdf`, {
            details: { ...details, from: this.name },
        });
    }
    getQuotesFromMessage(message) {
        const quotes = [];
        if (!message.attachments) {
            return quotes;
        }
        for (const attachment of message.attachments) {
            if ((0, core_typings_1.isQuoteAttachment)(attachment)) {
                const { text, author_name: name, md, ts } = attachment;
                if (text) {
                    quotes.push({
                        name,
                        md: md ?? (0, message_parser_1.parse)(text),
                        ts,
                    });
                }
                quotes.push(...this.getQuotesFromMessage({ attachments: attachment.attachments }));
            }
        }
        return quotes;
    }
    async getMessagesData(userId, messages) {
        const messagesData = [];
        for await (const message of messages) {
            if (!message.attachments?.length) {
                // If there's no attachment and no message, what was sent? lol
                messagesData.push({
                    _id: message._id,
                    files: [],
                    quotes: [],
                    ts: message.ts,
                    u: message.u,
                    msg: message.msg,
                    md: message.md,
                });
                continue;
            }
            const files = [];
            const quotes = [];
            for await (const attachment of message.attachments) {
                if ((0, core_typings_1.isQuoteAttachment)(attachment)) {
                    quotes.push(...this.getQuotesFromMessage(message));
                    continue;
                }
                if (!(0, core_typings_1.isFileAttachment)(attachment)) {
                    this.log.error(`Invalid attachment type ${attachment.type} for file ${attachment.title} in room ${message.rid}!`);
                    // ignore other types of attachments
                    continue;
                }
                if (!(0, core_typings_1.isFileImageAttachment)(attachment)) {
                    this.log.error(`Invalid attachment type ${attachment.type} for file ${attachment.title} in room ${message.rid}!`);
                    // ignore other types of attachments
                    files.push({ name: attachment.title, buffer: null });
                    continue;
                }
                if (!this.worker.isMimeTypeValid(attachment.image_type)) {
                    this.log.error(`Invalid mime type ${attachment.image_type} for file ${attachment.title} in room ${message.rid}!`);
                    // ignore invalid mime types
                    files.push({ name: attachment.title, buffer: null });
                    continue;
                }
                let file = message.files?.map((v) => ({ _id: v._id, name: v.name })).find((file) => file.name === attachment.title);
                if (!file) {
                    this.log.warn(`File ${attachment.title} not found in room ${message.rid}!`);
                    // For some reason, when an image is uploaded from clipboard, it doesn't have a file :(
                    // So, we'll try to get the FILE_ID from the `title_link` prop which has the format `/file-upload/FILE_ID/FILE_NAME` using a regex
                    const fileId = attachment.title_link?.match(/\/file-upload\/(.*)\/.*/)?.[1];
                    if (!fileId) {
                        this.log.error(`File ${attachment.title} not found in room ${message.rid}!`);
                        // ignore attachments without file
                        files.push({ name: attachment.title, buffer: null });
                        continue;
                    }
                    file = { _id: fileId, name: attachment.title || 'upload' };
                }
                if (!file) {
                    this.log.warn(`File ${attachment.title} not found in room ${message.rid}!`);
                    // ignore attachments without file
                    files.push({ name: attachment.title, buffer: null });
                    continue;
                }
                const uploadedFile = await models_1.Uploads.findOneById(file._id);
                if (!uploadedFile) {
                    this.log.error(`Uploaded file ${file._id} not found in room ${message.rid}!`);
                    // ignore attachments without file
                    files.push({ name: file.name, buffer: null });
                    continue;
                }
                const fileBuffer = await core_services_1.Upload.getFileBuffer({ userId, file: uploadedFile });
                files.push({ name: file.name, buffer: fileBuffer, extension: uploadedFile.extension });
            }
            // When you send a file message, the things you type in the modal are not "msg", they're in "description" of the attachment
            // So, we'll fetch the the msg, if empty, go for the first description on an attachment, if empty, empty string
            const msg = message.msg || message.attachments.find((attachment) => attachment.description)?.description || '';
            // Remove nulls from final array
            messagesData.push({
                _id: message._id,
                msg,
                u: message.u,
                files: files.filter(Boolean),
                quotes,
                ts: message.ts,
                md: message.md,
            });
        }
        return messagesData;
    }
    async getTranslations() {
        const keys = ['Agent', 'Date', 'Customer', 'Not_assigned', 'Time', 'Chat_transcript', 'This_attachment_is_not_supported'];
        return Promise.all(keys.map(async (key) => {
            return {
                key,
                value: await core_services_1.Translation.translateToServerLanguage(key),
            };
        }));
    }
    async workOnPdf({ details }) {
        this.log.info(`Processing transcript for room ${details.rid} by user ${details.userId} - Received from queue`);
        if (this.maxNumberOfConcurrentJobs <= this.currentJobNumber) {
            this.log.error(`Processing transcript for room ${details.rid} by user ${details.userId} - Too many concurrent jobs, queuing again`);
            throw new Error('retry');
        }
        this.currentJobNumber++;
        try {
            const room = await models_1.LivechatRooms.findOneById(details.rid);
            if (!room) {
                throw new Error('room-not-found');
            }
            const messages = await this.getMessagesFromRoom({ rid: room._id });
            const visitor = room.v &&
                (await models_1.LivechatVisitors.findOneEnabledById(room.v._id, { projection: { _id: 1, name: 1, username: 1, visitorEmails: 1 } }));
            const agent = room.servedBy && (await models_1.Users.findOneAgentById(room.servedBy._id, { projection: { _id: 1, name: 1, username: 1, utcOffset: 1 } }));
            const messagesData = await this.getMessagesData(details.userId, messages);
            const [siteName, dateFormat, timeAndDateFormat, timezone, translations] = await Promise.all([
                core_services_1.Settings.get('Site_Name'),
                core_services_1.Settings.get('Message_DateFormat'),
                core_services_1.Settings.get('Message_TimeAndDateFormat'),
                this.getTimezone(agent),
                this.getTranslations(),
            ]);
            const data = {
                visitor,
                agent,
                closedAt: room.closedAt,
                siteName,
                messages: messagesData,
                dateFormat,
                timeAndDateFormat,
                timezone,
                translations,
            };
            await this.doRender({ data, details });
        }
        catch (error) {
            await this.pdfFailed({ details, e: error });
        }
        finally {
            this.currentJobNumber--;
        }
    }
    async doRender({ data, details }) {
        const transcriptText = await core_services_1.Translation.translateToServerLanguage('Transcript');
        const stream = await this.worker.renderToStream({ data });
        const outBuff = await (0, tools_1.streamToBuffer)(stream);
        try {
            const file = await core_services_1.Upload.uploadFile({
                userId: details.userId,
                buffer: outBuff,
                details: {
                    // transcript_{company-name)_{date}_{hour}.pdf
                    name: `${transcriptText}_${data.siteName}_${new Intl.DateTimeFormat('en-US').format(new Date())}_${data.visitor?.name || data.visitor?.username || 'Visitor'}.pdf`,
                    type: 'application/pdf',
                    rid: details.rid,
                    // Rocket.cat is the goat
                    userId: 'rocket.cat',
                    size: outBuff.length,
                },
            });
            await this.pdfComplete({ details, file });
        }
        catch (e) {
            this.pdfFailed({ details, e });
        }
    }
    async pdfFailed({ details, e }) {
        this.log.error(`Transcript for room ${details.rid} by user ${details.userId} - Failed: ${e.message}`);
        const room = await models_1.LivechatRooms.findOneById(details.rid);
        if (!room) {
            return;
        }
        const user = await models_1.Users.findOneById(details.userId);
        if (!user) {
            return;
        }
        // Remove `transcriptRequestedPdf` from room to allow another request
        await models_1.LivechatRooms.unsetTranscriptRequestedPdfById(details.rid);
        const { rid } = await core_services_1.Room.createDirectMessage({ to: details.userId, from: 'rocket.cat' });
        this.log.info(`Transcript for room ${details.rid} by user ${details.userId} - Sending error message to user`);
        await core_services_1.Message.sendMessage({
            fromId: 'rocket.cat',
            rid,
            msg: `${await core_services_1.Translation.translate('pdf_error_message', user)}: ${e.message}`,
        });
    }
    async pdfComplete({ details, file }) {
        this.log.info(`Transcript for room ${details.rid} by user ${details.userId} - Complete`);
        const user = await models_1.Users.findOneById(details.userId);
        if (!user) {
            return;
        }
        // Send the file to the livechat room where this was requested, to keep it in context
        try {
            const [, { rid }] = await Promise.all([
                models_1.LivechatRooms.setPdfTranscriptFileIdById(details.rid, file._id),
                core_services_1.Room.createDirectMessage({ to: details.userId, from: 'rocket.cat' }),
            ]);
            this.log.info(`Transcript for room ${details.rid} by user ${details.userId} - Sending success message to user`);
            const result = await Promise.allSettled([
                core_services_1.Upload.sendFileMessage({
                    roomId: details.rid,
                    userId: 'rocket.cat',
                    file,
                    message: {
                        // Translate from service
                        msg: await core_services_1.Translation.translateToServerLanguage('pdf_success_message'),
                    },
                }),
                // Send the file to the user who requested it, so they can download it
                core_services_1.Upload.sendFileMessage({
                    roomId: rid,
                    userId: 'rocket.cat',
                    file,
                    message: {
                        // Translate from service
                        msg: await core_services_1.Translation.translate('pdf_success_message', user),
                    },
                }),
            ]);
            const e = result.find((r) => isPromiseRejectedResult(r));
            if (e && isPromiseRejectedResult(e)) {
                throw e.reason;
            }
        }
        catch (err) {
            this.log.error({ msg: `Transcript for room ${details.rid} by user ${details.userId} - Failed to send message`, err });
        }
    }
}
exports.OmnichannelTranscript = OmnichannelTranscript;
//# sourceMappingURL=OmnichannelTranscript.js.map