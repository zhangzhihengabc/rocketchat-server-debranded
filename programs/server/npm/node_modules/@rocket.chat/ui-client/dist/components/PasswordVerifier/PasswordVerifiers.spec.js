var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { jsx as _jsx } from "react/jsx-runtime";
import { mockAppRoot } from '@rocket.chat/mock-providers';
import { render, waitFor } from '@testing-library/react';
import { PasswordVerifier } from './PasswordVerifier';
afterEach(() => {
    // restore the spy created with spyOn
    jest.restoreAllMocks();
});
it('should render no policy if its disabled ', () => {
    const { queryByRole } = render(_jsx(PasswordVerifier, { password: '' }), {
        wrapper: mockAppRoot().withSetting('Accounts_Password_Policy_Enabled', 'true').build(),
    });
    expect(queryByRole('list')).toBeNull();
});
it('should render no policy if its enabled but empty', () => __awaiter(void 0, void 0, void 0, function* () {
    const { queryByRole, queryByTestId } = render(_jsx(PasswordVerifier, { password: 'asasdfafdgsdffdf' }), {
        wrapper: mockAppRoot().build(),
    });
    yield waitFor(() => {
        expect(queryByTestId('password-verifier-skeleton')).toBeNull();
    });
    expect(queryByRole('list')).toBeNull();
}));
it('should render policy list if its enabled and not empty', () => __awaiter(void 0, void 0, void 0, function* () {
    const { queryByRole, queryByTestId } = render(_jsx(PasswordVerifier, { password: 'asasdfafdgsdffdf' }), {
        wrapper: mockAppRoot()
            .withSetting('Accounts_Password_Policy_Enabled', 'true')
            .withSetting('Accounts_Password_Policy_MinLength', '6')
            .build(),
    });
    yield waitFor(() => {
        expect(queryByTestId('password-verifier-skeleton')).toBeNull();
    });
    expect(queryByRole('list')).toBeVisible();
    expect(queryByRole('listitem')).toBeVisible();
}));
it('should render all the policies when all policies are enabled', () => __awaiter(void 0, void 0, void 0, function* () {
    const { queryByTestId, queryAllByRole } = render(_jsx(PasswordVerifier, { password: 'asasdfafdgsdffdf' }), {
        wrapper: mockAppRoot()
            .withSetting('Accounts_Password_Policy_Enabled', 'true')
            .withSetting('Accounts_Password_Policy_MinLength', '6')
            .withSetting('Accounts_Password_Policy_MaxLength', '24')
            .withSetting('Accounts_Password_Policy_ForbidRepeatingCharacters', 'true')
            .withSetting('Accounts_Password_Policy_ForbidRepeatingCharactersCount', '3')
            .withSetting('Accounts_Password_Policy_AtLeastOneLowercase', 'true')
            .withSetting('Accounts_Password_Policy_AtLeastOneUppercase', 'true')
            .withSetting('Accounts_Password_Policy_AtLeastOneNumber', 'true')
            .withSetting('Accounts_Password_Policy_AtLeastOneSpecialCharacter', 'true')
            .build(),
    });
    yield waitFor(() => {
        expect(queryByTestId('password-verifier-skeleton')).toBeNull();
    });
    expect(queryAllByRole('listitem').length).toEqual(7);
}));
it("should render policy as invalid if password doesn't match the requirements", () => __awaiter(void 0, void 0, void 0, function* () {
    const { queryByTestId, getByRole } = render(_jsx(PasswordVerifier, { password: 'asd' }), {
        wrapper: mockAppRoot()
            .withSetting('Accounts_Password_Policy_Enabled', 'true')
            .withSetting('Accounts_Password_Policy_MinLength', '10')
            .build(),
    });
    yield waitFor(() => {
        expect(queryByTestId('password-verifier-skeleton')).toBeNull();
    });
    expect(getByRole('listitem', { name: 'get-password-policy-minLength-label' })).toHaveAttribute('aria-invalid', 'true');
}));
it('should render policy as valid if password matches the requirements', () => __awaiter(void 0, void 0, void 0, function* () {
    const { queryByTestId, getByRole } = render(_jsx(PasswordVerifier, { password: 'asd' }), {
        wrapper: mockAppRoot()
            .withSetting('Accounts_Password_Policy_Enabled', 'true')
            .withSetting('Accounts_Password_Policy_MinLength', '2')
            .build(),
    });
    yield waitFor(() => {
        expect(queryByTestId('password-verifier-skeleton')).toBeNull();
    });
    expect(getByRole('listitem', { name: 'get-password-policy-minLength-label' })).toHaveAttribute('aria-invalid', 'false');
}));
//# sourceMappingURL=PasswordVerifiers.spec.js.map