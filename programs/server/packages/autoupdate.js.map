{"version":3,"sources":["meteor://ðŸ’»app/packages/autoupdate/autoupdate_server.js","meteor://ðŸ’»app/packages/autoupdate/client_versions.js"],"names":["_objectSpread","module1","link","default","v","export","Autoupdate","ClientVersions","onMessage","Future","Npm","require","__meteor_runtime_config__","autoupdate","versions","clientVersions","autoupdateVersion","autoupdateVersionRefreshable","autoupdateVersionCordova","appId","process","env","APP_ID","syncQueue","Meteor","_SynchronousQueue","updateVersions","shouldReloadClientProgram","WebAppInternals","reloadClientPrograms","AUTOUPDATE_VERSION","clientArchs","Object","keys","WebApp","clientPrograms","forEach","arch","version","calculateClientHash","versionRefreshable","calculateClientHashRefreshable","versionNonRefreshable","calculateClientHashNonRefreshable","versionReplaceable","calculateClientHashReplaceable","versionHmr","hmrVersion","generateBoilerplate","onListening","payload","assets","getRefreshableAssets","set","publish","check","Match","OneOf","String","undefined","randomInterval","isProduction","Math","floor","random","stop","watch","isNew","setTimeout","added","changed","call","_id","onStop","ready","is_auto","startup","fut","queueTask","wait","return","enqueueVersionsRefresh","on","bindEnvironment","module","Tracker","constructor","_versions","Map","_watchCallbacks","Set","createStore","update","id","msg","fields","hasVersions","size","get","assign","fn","filter","skipInitial","resolved","Promise","resolve","then","callback","add","delete","newClientAvailable","currentVersion","isNewVersion","some","field","dependency","Dependency","depend"],"mappings":"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","file":"/packages/autoupdate.js","sourcesContent":["// Publish the current client versions for each client architecture\n// (web.browser, web.browser.legacy, web.cordova). When a client observes\n// a change in the versions associated with its client architecture,\n// it will refresh itself, either by swapping out CSS assets or by\n// reloading the page. Changes to the replaceable version are ignored\n// and handled by the hot-module-replacement package.\n//\n// There are four versions for any given client architecture: `version`,\n// `versionRefreshable`, `versionNonRefreshable`, and\n// `versionReplaceable`. The refreshable version is a hash of just the\n// client resources that are refreshable, such as CSS. The replaceable\n// version is a hash of files that can be updated with HMR. The\n// non-refreshable version is a hash of the rest of the client assets,\n// excluding the refreshable ones: HTML, JS that is not replaceable, and\n// static files in the `public` directory. The `version` version is a\n// combined hash of everything.\n//\n// If the environment variable `AUTOUPDATE_VERSION` is set, it will be\n// used in place of all client versions. You can use this variable to\n// control when the client reloads. For example, if you want to force a\n// reload only after major changes, use a custom AUTOUPDATE_VERSION and\n// change it only when something worth pushing to clients happens.\n//\n// The server publishes a `meteor_autoupdate_clientVersions` collection.\n// The ID of each document is the client architecture, and the fields of\n// the document are the versions described above.\n\nimport { ClientVersions } from \"./client_versions.js\";\nvar Future = Npm.require(\"fibers/future\");\n\nexport const Autoupdate = __meteor_runtime_config__.autoupdate = {\n\t// Map from client architectures (web.browser, web.browser.legacy,\n\t// web.cordova) to version fields { version, versionRefreshable,\n\t// versionNonRefreshable, refreshable } that will be stored in\n\t// ClientVersions documents (whose IDs are client architectures). This\n\t// data gets serialized into the boilerplate because it's stored in\n\t// __meteor_runtime_config__.autoupdate.versions.\n\tversions: {}\n};\n\n// Stores acceptable client versions.\nconst clientVersions = new ClientVersions();\n\n// The client hash includes __meteor_runtime_config__, so wait until\n// all packages have loaded and have had a chance to populate the\n// runtime config before using the client hash as our default auto\n// update version id.\n\n// Note: Tests allow people to override Autoupdate.autoupdateVersion before\n// startup.\nAutoupdate.autoupdateVersion = null;\nAutoupdate.autoupdateVersionRefreshable = null;\nAutoupdate.autoupdateVersionCordova = null;\nAutoupdate.appId = __meteor_runtime_config__.appId = process.env.APP_ID;\n\nvar syncQueue = new Meteor._SynchronousQueue();\n\nfunction updateVersions(shouldReloadClientProgram) {\n\t// Step 1: load the current client program on the server\n\tif (shouldReloadClientProgram) {\n\t\tWebAppInternals.reloadClientPrograms();\n\t}\n\n\tconst {\n\t\t// If the AUTOUPDATE_VERSION environment variable is defined, it takes\n\t\t// precedence, but Autoupdate.autoupdateVersion is still supported as\n\t\t// a fallback. In most cases neither of these values will be defined.\n\t\tAUTOUPDATE_VERSION = Autoupdate.autoupdateVersion\n\t} = process.env;\n\n\t// Step 2: update __meteor_runtime_config__.autoupdate.versions.\n\tconst clientArchs = Object.keys(WebApp.clientPrograms);\n\tclientArchs.forEach(arch => {\n\t\tAutoupdate.versions[arch] = {\n\t\t\tversion: AUTOUPDATE_VERSION ||\n\t\t\t\tWebApp.calculateClientHash(arch),\n\t\t\tversionRefreshable: AUTOUPDATE_VERSION ||\n\t\t\t\tWebApp.calculateClientHashRefreshable(arch),\n\t\t\tversionNonRefreshable: AUTOUPDATE_VERSION ||\n\t\t\t\tWebApp.calculateClientHashNonRefreshable(arch),\n\t\t\tversionReplaceable: AUTOUPDATE_VERSION ||\n\t\t\t\tWebApp.calculateClientHashReplaceable(arch),\n\t\t\tversionHmr: WebApp.clientPrograms[arch].hmrVersion\n\t\t};\n\t});\n\n\t// Step 3: form the new client boilerplate which contains the updated\n\t// assets and __meteor_runtime_config__.\n\tif (shouldReloadClientProgram) {\n\t\tWebAppInternals.generateBoilerplate();\n\t}\n\n\t// Step 4: update the ClientVersions collection.\n\t// We use `onListening` here because we need to use\n\t// `WebApp.getRefreshableAssets`, which is only set after\n\t// `WebApp.generateBoilerplate` is called by `main` in webapp.\n\tWebApp.onListening(() => {\n\t\tclientArchs.forEach(arch => {\n\t\t\tconst payload = {\n\t\t\t\t...Autoupdate.versions[arch],\n\t\t\t\tassets: WebApp.getRefreshableAssets(arch),\n\t\t\t};\n\n\t\t\tclientVersions.set(arch, payload);\n\t\t});\n\t});\n}\n\nMeteor.publish(\n\t\"meteor_autoupdate_clientVersions\",\n\tfunction (appId) {\n\t\t// `null` happens when a client doesn't have an appId and passes\n\t\t// `undefined` to `Meteor.subscribe`. `undefined` is translated to\n\t\t// `null` as JSON doesn't have `undefined.\n\t\tcheck(appId, Match.OneOf(String, undefined, null));\n\n\t\t// Don't notify clients using wrong appId such as mobile apps built with a\n\t\t// different server but pointing at the same local url\n\t\tif (Autoupdate.appId && appId && Autoupdate.appId !== appId)\n\t\t\treturn [];\n\n\t\t// Random value to delay the updates for 2-10 minutes\n\t\tconst randomInterval = Meteor.isProduction ? (Math.floor(Math.random() * 8) + 2) * 1000 * 60 : 0;\n\n\t\tconst stop = clientVersions.watch((version, isNew) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\t(isNew ? this.added : this.changed)\n\t\t\t\t.call(this, \"meteor_autoupdate_clientVersions\", version._id, version)\n\t\t\t}, randomInterval);\n\t\t});\n\n\t\tthis.onStop(() => stop());\n\t\tthis.ready();\n\t},\n\t{is_auto: true}\n);\n\nMeteor.startup(function () {\n\tupdateVersions(false);\n\n\t// Force any connected clients that are still looking for these older\n\t// document IDs to reload.\n\t[\"version\",\n\t \"version-refreshable\",\n\t \"version-cordova\",\n\t].forEach(_id => {\n\t\tclientVersions.set(_id, {\n\t\t\tversion: \"outdated\"\n\t\t});\n\t});\n});\n\nvar fut = new Future();\n\n// We only want 'refresh' to trigger 'updateVersions' AFTER onListen,\n// so we add a queued task that waits for onListen before 'refresh' can queue\n// tasks. Note that the `onListening` callbacks do not fire until after\n// Meteor.startup, so there is no concern that the 'updateVersions' calls from\n// 'refresh' will overlap with the `updateVersions` call from Meteor.startup.\n\nsyncQueue.queueTask(function () {\n\tfut.wait();\n});\n\nWebApp.onListening(function () {\n\tfut.return();\n});\n\nfunction enqueueVersionsRefresh() {\n\tsyncQueue.queueTask(function () {\n\t\tupdateVersions(true);\n\t});\n}\n\n// Listen for messages pertaining to the client-refresh topic.\nimport { onMessage } from \"meteor/inter-process-messaging\";\nonMessage(\"client-refresh\", enqueueVersionsRefresh);\n\n// Another way to tell the process to refresh: send SIGHUP signal\nprocess.on('SIGHUP', Meteor.bindEnvironment(function () {\n\tenqueueVersionsRefresh();\n}, \"handling SIGHUP signal for refresh\"));\n","import { Tracker } from \"meteor/tracker\";\n\nexport class ClientVersions {\n\tconstructor() {\n\t\tthis._versions = new Map();\n\t\tthis._watchCallbacks = new Set();\n\t}\n\n\t// Creates a Livedata store for use with `Meteor.connection.registerStore`.\n\t// After the store is registered, document updates reported by Livedata are\n\t// merged with the documents in this `ClientVersions` instance.\n\tcreateStore() {\n\t\treturn {\n\t\t\tupdate: ({ id, msg, fields }) => {\n\t\t\t\tif (msg === \"added\" || msg === \"changed\") {\n\t\t\t\t\tthis.set(id, fields);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\thasVersions() {\n\t\treturn this._versions.size > 0;\n\t}\n\n\tget(id) {\n\t\treturn this._versions.get(id);\n\t}\n\n\t// Adds or updates a version document and invokes registered callbacks for the\n\t// added/updated document. If a document with the given ID already exists, its\n\t// fields are merged with `fields`.\n\tset(id, fields) {\n\t\tlet version = this._versions.get(id);\n\t\tlet isNew = false;\n\n\t\tif (version) {\n\t\t\tObject.assign(version, fields);\n\t\t} else {\n\t\t\tversion = {\n\t\t\t\t_id: id,\n\t\t\t\t...fields\n\t\t\t};\n\n\t\t\tisNew = true;\n\t\t\tthis._versions.set(id, version);\n\t\t}\n\n\t\tthis._watchCallbacks.forEach(({ fn, filter }) => {\n\t\t\tif (! filter || filter === version._id) {\n\t\t\t\tfn(version, isNew);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Registers a callback that will be invoked when a version document is added\n\t// or changed. Calling the function returned by `watch` removes the callback.\n\t// If `skipInitial` is true, the callback isn't be invoked for existing\n\t// documents. If `filter` is set, the callback is only invoked for documents\n\t// with ID `filter`.\n\twatch(fn, { skipInitial, filter } = {}) {\n\t\tif (! skipInitial) {\n\t\t\tconst resolved = Promise.resolve();\n\n\t\t\tthis._versions.forEach((version) => {\n\t\t\t\tif (! filter || filter === version._id) {\n\t\t\t\t\tresolved.then(() => fn(version, true));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst callback = { fn, filter };\n\t\tthis._watchCallbacks.add(callback);\n\n\t\treturn () => this._watchCallbacks.delete(callback);\n\t}\n\n\t// A reactive data source for `Autoupdate.newClientAvailable`.\n\tnewClientAvailable(id, fields, currentVersion) {\n\t\tfunction isNewVersion(version) {\n\t\t\treturn (\n\t\t\t\tversion._id === id &&\n\t\t\t\tfields.some((field) => version[field] !== currentVersion[field])\n\t\t\t);\n\t\t}\n\n\t\tconst dependency = new Tracker.Dependency();\n\t\tconst version = this.get(id);\n\n\t\tdependency.depend();\n\n\t\tconst stop = this.watch(\n\t\t\t(version) => {\n\t\t\t\tif (isNewVersion(version)) {\n\t\t\t\t\tdependency.changed();\n\t\t\t\t\tstop();\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ skipInitial: true }\n\t\t);\n\n\t\treturn !! version && isNewVersion(version);\n\t}\n}\n"]}