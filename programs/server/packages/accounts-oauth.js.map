{"version":3,"sources":["meteor://ðŸ’»app/packages/accounts-oauth/oauth_common.js","meteor://ðŸ’»app/packages/accounts-oauth/oauth_server.js"],"names":["Meteor","module","link","v","VALID_CONFIG_KEYS","Accounts","oauth","services","hasOwn","Object","prototype","hasOwnProperty","registerService","name","call","Error","server","users","createIndex","unique","sparse","unregisterService","serviceNames","keys","startup","ServiceConfiguration","Package","loginServiceConfiguration","configurations","ConfigError","settings","packages","oauthSecretKey","OAuthEncryption","loadKey","forEach","key","includes","_options","registerLoginHandler","options","undefined","check","credentialToken","String","credentialSecret","Match","OneOf","result","OAuth","retrieveCredential","type","error","LoginCancelledError","numericError","serviceName","updateOrCreateUserFromExternalService","serviceData","usingOAuthEncryption","keyIsLoaded","find","$and","secret","$exists","config","update","_id","$set","seal"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAIA,MAAM;AAACC,MAAM,CAACC,IAAI,CAAC,eAAe,EAAC;EAACF,MAAM,CAACG,CAAC,EAAC;IAACH,MAAM,GAACG,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAE/D;AACA;AACA,MAAMC,iBAAiB,GAAG,CACxB,uBAAuB,EACvB,6BAA6B,EAC7B,+BAA+B,EAC/B,qCAAqC,EACrC,+BAA+B,EAC/B,uBAAuB,EACvB,iBAAiB,EACjB,oCAAoC,EACpC,8BAA8B,EAC9B,wBAAwB,EACxB,cAAc,EACd,sBAAsB,EACtB,2BAA2B,EAC3B,qBAAqB,CACtB;AAEDC,QAAQ,CAACC,KAAK,GAAG,CAAC,CAAC;AAEnB,MAAMC,QAAQ,GAAG,CAAC,CAAC;AACnB,MAAMC,MAAM,GAAGC,MAAM,CAACC,SAAS,CAACC,cAAc;;AAE9C;AACA;AACAN,QAAQ,CAACC,KAAK,CAACM,eAAe,GAAGC,IAAI,IAAI;EACvC,IAAIL,MAAM,CAACM,IAAI,CAACP,QAAQ,EAAEM,IAAI,CAAC,EAC7B,MAAM,IAAIE,KAAK,8BAAuBF,IAAI,EAAG;EAC/CN,QAAQ,CAACM,IAAI,CAAC,GAAG,IAAI;EAErB,IAAIb,MAAM,CAACgB,MAAM,EAAE;IACjB;IACA;IACA;IACA;IACAhB,MAAM,CAACiB,KAAK,CAACC,WAAW,oBAAaL,IAAI,UAAO;MAACM,MAAM,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAI,CAAC,CAAC;EAC/E;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAf,QAAQ,CAACC,KAAK,CAACe,iBAAiB,GAAGR,IAAI,IAAI;EACzC,IAAI,CAACL,MAAM,CAACM,IAAI,CAACP,QAAQ,EAAEM,IAAI,CAAC,EAC9B,MAAM,IAAIE,KAAK,8BAAuBF,IAAI,EAAG;EAC/C,OAAON,QAAQ,CAACM,IAAI,CAAC;AACvB,CAAC;AAEDR,QAAQ,CAACC,KAAK,CAACgB,YAAY,GAAG,MAAMb,MAAM,CAACc,IAAI,CAAChB,QAAQ,CAAC;;AAEzD;AACAP,MAAM,CAACwB,OAAO,CAAC,MAAM;EAAA;EACnB,MAAM;IAAEC;EAAqB,CAAC,GAAGC,OAAO,CAAC,uBAAuB,CAAC;EACjErB,QAAQ,CAACsB,yBAAyB,GAAGF,oBAAoB,CAACG,cAAc;EACxEvB,QAAQ,CAACwB,WAAW,GAAGJ,oBAAoB,CAACI,WAAW;EAEvD,MAAMC,QAAQ,uBAAG9B,MAAM,CAAC8B,QAAQ,8EAAf,iBAAiBC,QAAQ,0DAAzB,sBAA4B,eAAe,CAAC;EAC7D,IAAID,QAAQ,EAAE;IACZ,IAAIA,QAAQ,CAACE,cAAc,EAAE;MAC3B,IAAI,CAACN,OAAO,CAAC,kBAAkB,CAAC,EAAE;QAChC,MAAM,IAAIX,KAAK,CACb,mEAAmE,CACpE;MACH;MACAW,OAAO,CAAC,kBAAkB,CAAC,CAACO,eAAe,CAACC,OAAO,CACjDJ,QAAQ,CAACE,cAAc,CACxB;MACD,OAAOF,QAAQ,CAACE,cAAc;IAChC;IACA;IACAvB,MAAM,CAACc,IAAI,CAACO,QAAQ,CAAC,CAACK,OAAO,CAACC,GAAG,IAAI;MACnC,IAAI,CAAChC,iBAAiB,CAACiC,QAAQ,CAACD,GAAG,CAAC,EAAE;QACpC;QACA,MAAM,IAAIpC,MAAM,CAACe,KAAK,gDACoBqB,GAAG,EAC5C;MACH,CAAC,MAAM;QACL;QACA/B,QAAQ,CAACiC,QAAQ,CAACF,GAAG,CAAC,GAAGN,QAAQ,CAACM,GAAG,CAAC;MACxC;IACF,CAAC,CAAC;EACJ;AACF,CAAC,CAAC,C;;;;;;;;;;;;ACvFF,IAAIpC,MAAM;AAACC,MAAM,CAACC,IAAI,CAAC,eAAe,EAAC;EAACF,MAAM,CAACG,CAAC,EAAC;IAACH,MAAM,GAACG,CAAC;EAAA;AAAC,CAAC,EAAC,CAAC,CAAC;AAE/D;AACA;AACAE,QAAQ,CAACkC,oBAAoB,CAACC,OAAO,IAAI;EACvC,IAAI,CAACA,OAAO,CAAClC,KAAK,EAChB,OAAOmC,SAAS,CAAC,CAAC;;EAEpBC,KAAK,CAACF,OAAO,CAAClC,KAAK,EAAE;IACnBqC,eAAe,EAAEC,MAAM;IACvB;IACA;IACA;IACA;IACAC,gBAAgB,EAAEC,KAAK,CAACC,KAAK,CAAC,IAAI,EAAEH,MAAM;EAC5C,CAAC,CAAC;EAEF,MAAMI,MAAM,GAAGC,KAAK,CAACC,kBAAkB,CAACV,OAAO,CAAClC,KAAK,CAACqC,eAAe,EAC/BH,OAAO,CAAClC,KAAK,CAACuC,gBAAgB,CAAC;EAErE,IAAI,CAACG,MAAM,EAAE;IACX;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAO;MAAEG,IAAI,EAAE,OAAO;MACbC,KAAK,EAAE,IAAIpD,MAAM,CAACe,KAAK,CACrBV,QAAQ,CAACgD,mBAAmB,CAACC,YAAY,EACzC,iCAAiC;IAAE,CAAC;EACjD;EAEA,IAAIN,MAAM,YAAYjC,KAAK;IACzB;IACA;IACA,MAAMiC,MAAM,CAAC,KACV;IACH,IAAI,CAAE3C,QAAQ,CAACC,KAAK,CAACgB,YAAY,EAAE,CAACe,QAAQ,CAACW,MAAM,CAACO,WAAW,CAAC,EAAE;MAChE;MACA;MACA;MACA,OAAO;QAAEJ,IAAI,EAAE,OAAO;QACbC,KAAK,EAAE,IAAIpD,MAAM,CAACe,KAAK,CACrBV,QAAQ,CAACgD,mBAAmB,CAACC,YAAY,mDACCN,MAAM,CAACO,WAAW;MAAI,CAAC;IAE9E;IACA,OAAOlD,QAAQ,CAACmD,qCAAqC,CAACR,MAAM,CAACO,WAAW,EAAEP,MAAM,CAACS,WAAW,EAAET,MAAM,CAACR,OAAO,CAAC;EAC/G;AACF,CAAC,CAAC;;AAEF;AACA;AACA;;AAEA,MAAMP,eAAe,2BAAGP,OAAO,CAAC,kBAAkB,CAAC,yDAA3B,qBAA6BO,eAAe;AAEpE,MAAMyB,oBAAoB,GAAG,MAAM;EACjC,OAAOzB,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE0B,WAAW,EAAE;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA3D,MAAM,CAACwB,OAAO,CAAC,MAAM;EACnB,IAAI,CAAEkC,oBAAoB,EAAE,EAAE;IAC5B;EACF;EAEA,MAAM;IAAEjC;EAAqB,CAAC,GAAGC,OAAO,CAAC,uBAAuB,CAAC;EAEjED,oBAAoB,CAACG,cAAc,CAACgC,IAAI,CAAC;IACvCC,IAAI,EAAE,CAAC;MACLC,MAAM,EAAE;QAAEC,OAAO,EAAE;MAAK;IAC1B,CAAC,EAAE;MACD,kBAAkB,EAAE;QAAEA,OAAO,EAAE;MAAM;IACvC,CAAC;EACH,CAAC,CAAC,CAAC5B,OAAO,CAAC6B,MAAM,IAAI;IACnBvC,oBAAoB,CAACG,cAAc,CAACqC,MAAM,CAACD,MAAM,CAACE,GAAG,EAAE;MACrDC,IAAI,EAAE;QACJL,MAAM,EAAE7B,eAAe,CAACmC,IAAI,CAACJ,MAAM,CAACF,MAAM;MAC5C;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC,CAAC,C","file":"/packages/accounts-oauth.js","sourcesContent":["import { Meteor } from 'meteor/meteor';\n\n// TODO get from account-base\n// config option keys\nconst VALID_CONFIG_KEYS = [\n  'sendVerificationEmail',\n  'forbidClientAccountCreation',\n  'passwordEnrollTokenExpiration',\n  'passwordEnrollTokenExpirationInDays',\n  'restrictCreationByEmailDomain',\n  'loginExpirationInDays',\n  'loginExpiration',\n  'passwordResetTokenExpirationInDays',\n  'passwordResetTokenExpiration',\n  'ambiguousErrorMessages',\n  'bcryptRounds',\n  'defaultFieldSelector',\n  'loginTokenExpirationHours',\n  'tokenSequenceLength',\n];\n\nAccounts.oauth = {};\n\nconst services = {};\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// Helper for registering OAuth based accounts packages.\n// On the server, adds an index to the user collection.\nAccounts.oauth.registerService = name => {\n  if (hasOwn.call(services, name))\n    throw new Error(`Duplicate service: ${name}`);\n  services[name] = true;\n\n  if (Meteor.server) {\n    // Accounts.updateOrCreateUserFromExternalService does a lookup by this id,\n    // so this should be a unique index. You might want to add indexes for other\n    // fields returned by your service (eg services.github.login) but you can do\n    // that in your app.\n    Meteor.users.createIndex(`services.${name}.id`, {unique: true, sparse: true});\n  }\n};\n\n// Removes a previously registered service.\n// This will disable logging in with this service, and serviceNames() will not\n// contain it.\n// It's worth noting that already logged in users will remain logged in unless\n// you manually expire their sessions.\nAccounts.oauth.unregisterService = name => {\n  if (!hasOwn.call(services, name))\n    throw new Error(`Service not found: ${name}`);\n  delete services[name];\n};\n\nAccounts.oauth.serviceNames = () => Object.keys(services);\n\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\nMeteor.startup(() => {\n  const { ServiceConfiguration } = Package['service-configuration'];\n  Accounts.loginServiceConfiguration = ServiceConfiguration.configurations;\n  Accounts.ConfigError = ServiceConfiguration.ConfigError;\n\n  const settings = Meteor.settings?.packages?.['accounts-base'];\n  if (settings) {\n    if (settings.oauthSecretKey) {\n      if (!Package['oauth-encryption']) {\n        throw new Error(\n          'The oauth-encryption package must be loaded to set oauthSecretKey'\n        );\n      }\n      Package['oauth-encryption'].OAuthEncryption.loadKey(\n        settings.oauthSecretKey\n      );\n      delete settings.oauthSecretKey;\n    }\n    // Validate config options keys\n    Object.keys(settings).forEach(key => {\n      if (!VALID_CONFIG_KEYS.includes(key)) {\n        // TODO Consider just logging a debug message instead to allow for additional keys in the settings here?\n        throw new Meteor.Error(\n          `Accounts configuration: Invalid key: ${key}`\n        );\n      } else {\n        // set values in Accounts._options\n        Accounts._options[key] = settings[key];\n      }\n    });\n  }\n});\n","import { Meteor } from 'meteor/meteor';\n\n// Listen to calls to `login` with an oauth option set. This is where\n// users actually get logged in to meteor via oauth.\nAccounts.registerLoginHandler(options => {\n  if (!options.oauth)\n    return undefined; // don't handle\n\n  check(options.oauth, {\n    credentialToken: String,\n    // When an error occurs while retrieving the access token, we store\n    // the error in the pending credentials table, with a secret of\n    // null. The client can call the login method with a secret of null\n    // to retrieve the error.\n    credentialSecret: Match.OneOf(null, String)\n  });\n\n  const result = OAuth.retrieveCredential(options.oauth.credentialToken,\n                                        options.oauth.credentialSecret);\n\n  if (!result) {\n    // OAuth credentialToken is not recognized, which could be either\n    // because the popup was closed by the user before completion, or\n    // some sort of error where the oauth provider didn't talk to our\n    // server correctly and closed the popup somehow.\n    //\n    // We assume it was user canceled and report it as such, using a\n    // numeric code that the client recognizes (XXX this will get\n    // replaced by a symbolic error code at some point\n    // https://trello.com/c/kMkw800Z/53-official-ddp-specification). This\n    // will mask failures where things are misconfigured such that the\n    // server doesn't see the request but does close the window. This\n    // seems unlikely.\n    //\n    // XXX we want `type` to be the service name such as \"facebook\"\n    return { type: \"oauth\",\n             error: new Meteor.Error(\n               Accounts.LoginCancelledError.numericError,\n               \"No matching login attempt found\") };\n  }\n\n  if (result instanceof Error)\n    // We tried to login, but there was a fatal error. Report it back\n    // to the user.\n    throw result;\n  else {\n    if (! Accounts.oauth.serviceNames().includes(result.serviceName)) {\n      // serviceName was not found in the registered services list.\n      // This could happen because the service never registered itself or\n      // unregisterService was called on it.\n      return { type: \"oauth\",\n               error: new Meteor.Error(\n                 Accounts.LoginCancelledError.numericError,\n                 `No registered oauth service found for: ${result.serviceName}`) };\n\n    }\n    return Accounts.updateOrCreateUserFromExternalService(result.serviceName, result.serviceData, result.options);\n  }\n});\n\n///\n/// OAuth Encryption Support\n///\n\nconst OAuthEncryption = Package[\"oauth-encryption\"]?.OAuthEncryption;\n\nconst usingOAuthEncryption = () => {\n  return OAuthEncryption?.keyIsLoaded();\n};\n\n// Encrypt unencrypted login service secrets when oauth-encryption is\n// added.\n//\n// XXX For the oauthSecretKey to be available here at startup, the\n// developer must call Accounts.config({oauthSecretKey: ...}) at load\n// time, instead of in a Meteor.startup block, because the startup\n// block in the app code will run after this accounts-base startup\n// block.  Perhaps we need a post-startup callback?\n\nMeteor.startup(() => {\n  if (! usingOAuthEncryption()) {\n    return;\n  }\n\n  const { ServiceConfiguration } = Package['service-configuration'];\n\n  ServiceConfiguration.configurations.find({\n    $and: [{\n      secret: { $exists: true }\n    }, {\n      \"secret.algorithm\": { $exists: false }\n    }]\n  }).forEach(config => {\n    ServiceConfiguration.configurations.update(config._id, {\n      $set: {\n        secret: OAuthEncryption.seal(config.secret)\n      }\n    });\n  });\n});\n"]}