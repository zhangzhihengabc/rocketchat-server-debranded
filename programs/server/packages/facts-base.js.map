{"version":3,"sources":["meteor://ðŸ’»app/packages/facts-base/facts_base_server.js","meteor://ðŸ’»app/packages/facts-base/facts_base_common.js"],"names":["module","export","Facts","FACTS_COLLECTION","FACTS_PUBLICATION","link","v","hasOwn","Object","prototype","hasOwnProperty","userIdFilter","userId","Package","autopublish","setUserIdFilter","filter","factsByPackage","activeSubscriptions","_factsByPackage","incrementServerFact","pkg","fact","increment","call","forEach","sub","added","packageFacts","changedField","changed","Meteor","defer","publish","ready","push","keys","onStop","activeSub","is_auto"],"mappings":"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","file":"/packages/facts-base.js","sourcesContent":["import { Facts, FACTS_COLLECTION, FACTS_PUBLICATION } from './facts_base_common';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// This file is only used server-side, so no need to check Meteor.isServer.\n\n// By default, we publish facts to no user if autopublish is off, and to all\n// users if autopublish is on.\nlet userIdFilter = function (userId) {\n  return !!Package.autopublish;\n};\n\n// XXX make this take effect at runtime too?\nFacts.setUserIdFilter = function (filter) {\n  userIdFilter = filter;\n};\n\n// XXX Use a minimongo collection instead and hook up an observeChanges\n// directly to a publish.\nconst factsByPackage = {};\nlet activeSubscriptions = [];\n\n// Make factsByPackage data available to the server environment\nFacts._factsByPackage = factsByPackage;\n\nFacts.incrementServerFact = function (pkg, fact, increment) {\n  if (!hasOwn.call(factsByPackage, pkg)) {\n    factsByPackage[pkg] = {};\n    factsByPackage[pkg][fact] = increment;\n    activeSubscriptions.forEach(function (sub) {\n      sub.added(FACTS_COLLECTION, pkg, factsByPackage[pkg]);\n    });\n    return;\n  }\n\n  const packageFacts = factsByPackage[pkg];\n  if (!hasOwn.call(packageFacts, fact)) {\n    factsByPackage[pkg][fact] = 0;\n  }\n  factsByPackage[pkg][fact] += increment;\n  const changedField = {};\n  changedField[fact] = factsByPackage[pkg][fact];\n  activeSubscriptions.forEach(function (sub) {\n    sub.changed(FACTS_COLLECTION, pkg, changedField);\n  });\n};\n\n// Deferred, because we have an unordered dependency on livedata.\n// XXX is this safe? could somebody try to connect before Meteor.publish is\n// called?\nMeteor.defer(function () {\n  // XXX Also publish facts-by-package.\n  Meteor.publish(FACTS_PUBLICATION, function () {\n    const sub = this;\n    if (!userIdFilter(this.userId)) {\n      sub.ready();\n      return;\n    }\n\n    activeSubscriptions.push(sub);\n    Object.keys(factsByPackage).forEach(function (pkg) {\n      sub.added(FACTS_COLLECTION, pkg, factsByPackage[pkg]);\n    });\n    sub.onStop(function () {\n      activeSubscriptions =\n        activeSubscriptions.filter(activeSub => activeSub !== sub);\n    });\n    sub.ready();\n  }, {is_auto: true});\n});\n\nexport {\n  Facts,\n  FACTS_COLLECTION,\n  FACTS_PUBLICATION,\n};\n","const Facts = {};\nconst FACTS_COLLECTION = 'meteor_Facts_server';\nconst FACTS_PUBLICATION = 'meteor_facts';\n\nexport {\n  Facts,\n  FACTS_COLLECTION,\n  FACTS_PUBLICATION,\n};\n"]}