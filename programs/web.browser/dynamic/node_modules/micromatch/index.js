function module(t,e,r){"use strict";let n=t("util"),o=t("braces"),a=t("picomatch"),s=t("picomatch/lib/utils"),c=t=>""===t||"./"===t,i=(t,e,r)=>{e=[].concat(e),t=[].concat(t);let n=new Set,o=new Set,s=new Set,c=0,i=t=>{s.add(t.output),r&&r.onResult&&r.onResult(t)};for(let s=0;s<e.length;s++){let l=a(String(e[s]),{...r,onResult:i},!0),u=l.state.negated||l.state.negatedExtglob;for(let e of(u&&c++,t)){let t=l(e,!0);(u?!t.isMatch:t.isMatch)&&(u?n.add(t.output):(n.delete(t.output),o.add(t.output)))}}let l=(c===e.length?[...s]:[...o]).filter(t=>!n.has(t));if(r&&0===l.length){if(!0===r.failglob)throw Error(`No matches found for "${e.join(", ")}"`);if(!0===r.nonull||!0===r.nullglob)return r.unescape?e.map(t=>t.replace(/\\/g,"")):e}return l};i.match=i,i.matcher=(t,e)=>a(t,e),i.isMatch=(t,e,r)=>a(e,r)(t),i.any=i.isMatch,i.not=(t,e,r={})=>{e=[].concat(e).map(String);let n=new Set,o=[],a=new Set(i(t,e,{...r,onResult:t=>{r.onResult&&r.onResult(t),o.push(t.output)}}));for(let t of o)a.has(t)||n.add(t);return[...n]},i.contains=(t,e,r)=>{if("string"!=typeof t)throw TypeError(`Expected a string: "${n.inspect(t)}"`);if(Array.isArray(e))return e.some(e=>i.contains(t,e,r));if("string"==typeof e){if(c(t)||c(e))return!1;if(t.includes(e)||t.startsWith("./")&&t.slice(2).includes(e))return!0}return i.isMatch(t,e,{...r,contains:!0})},i.matchKeys=(t,e,r)=>{if(!s.isObject(t))throw TypeError("Expected the first argument to be an object");let n=i(Object.keys(t),e,r),o={};for(let e of n)o[e]=t[e];return o},i.some=(t,e,r)=>{let n=[].concat(t);for(let t of[].concat(e)){let e=a(String(t),r);if(n.some(t=>e(t)))return!0}return!1},i.every=(t,e,r)=>{let n=[].concat(t);for(let t of[].concat(e)){let e=a(String(t),r);if(!n.every(t=>e(t)))return!1}return!0},i.all=(t,e,r)=>{if("string"!=typeof t)throw TypeError(`Expected a string: "${n.inspect(t)}"`);return[].concat(e).every(e=>a(e,r)(t))},i.capture=(t,e,r)=>{let n=s.isWindows(r),o=a.makeRe(String(t),{...r,capture:!0}).exec(n?s.toPosixSlashes(e):e);if(o)return o.slice(1).map(t=>void 0===t?"":t)},i.makeRe=(...t)=>a.makeRe(...t),i.scan=(...t)=>a.scan(...t),i.parse=(t,e)=>{let r=[];for(let n of[].concat(t||[]))for(let t of o(String(n),e))r.push(a.parse(t,e));return r},i.braces=(t,e)=>{if("string"!=typeof t)throw TypeError("Expected a string");return e&&!0===e.nobrace||!/\{.*\}/.test(t)?[t]:o(t,e)},i.braceExpand=(t,e)=>{if("string"!=typeof t)throw TypeError("Expected a string");return i.braces(t,{...e,expand:!0})},r.exports=i}
//# sourceMappingURL=/dynamic/node_modules/micromatch/05526437ac8b0c6aac5370421f98f3413924b4a1.map
