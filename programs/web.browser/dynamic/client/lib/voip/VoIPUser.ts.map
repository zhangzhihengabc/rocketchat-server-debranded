)]}'
{"version":3,"sources":["meteor://ðŸ’»app/client/lib/voip/VoIPUser.ts","meteor://ðŸ’»app/<anon>"],"sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protocol details.\n */\nimport type {\n\tCallStates,\n\tConnectionState,\n\tICallerInfo,\n\tIQueueMembershipSubscription,\n\tSignalingSocketEvents,\n\tSocketEventKeys,\n\tIMediaStreamRenderer,\n\tVoIPUserConfiguration,\n\tVoIpCallerInfo,\n\tIState,\n\tVoipEvents,\n} from '@rocket.chat/core-typings';\nimport { Operation, UserState, WorkflowTypes } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport type { UserAgentOptions, InvitationAcceptOptions, Session, SessionInviteOptions } from 'sip.js';\nimport { UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter } from 'sip.js';\nimport type { OutgoingByeRequest, OutgoingRequestDelegate } from 'sip.js/lib/core';\nimport { URI } from 'sip.js/lib/core';\nimport type { SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\nimport { SessionDescriptionHandler } from 'sip.js/lib/platform/web';\n\nimport { toggleMediaStreamTracks } from './Helper';\nimport LocalStream from './LocalStream';\nimport { QueueAggregator } from './QueueAggregator';\nimport RemoteStream from './RemoteStream';\n\nexport class VoIPUser extends Emitter<VoipEvents> {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate remoteStream: RemoteStream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _connectionState: ConnectionState = 'INITIAL';\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tprivate connectionRetryCount;\n\n\tprivate stop;\n\n\tprivate networkEmitter: Emitter<SignalingSocketEvents>;\n\n\tprivate offlineNetworkHandler: () => void;\n\n\tprivate onlineNetworkHandler: () => void;\n\n\tprivate optionsKeepaliveInterval = 5;\n\n\tprivate optionsKeepAliveDebounceTimeInSec = 5;\n\n\tprivate attemptRegistration = false;\n\n\tprotected session: Session | undefined;\n\n\tprotected _callState: CallStates = 'INITIAL';\n\n\tprotected _callerInfo: ICallerInfo | undefined;\n\n\tprotected _userState: UserState = UserState.IDLE;\n\n\tprotected _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.networkEmitter = new Emitter<SignalingSocketEvents>();\n\t\tthis.connectionRetryCount = this.config.connectionRetryCount;\n\t\tthis.stop = false;\n\n\t\tthis.onlineNetworkHandler = this.onNetworkRestored.bind(this);\n\t\tthis.offlineNetworkHandler = this.onNetworkLost.bind(this);\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true,\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis.userAgent.transport.isConnected();\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\ttry {\n\t\t\tthis.registerer = new Registerer(this.userAgent);\n\n\t\t\tthis.userAgent.transport.onConnect = this.onConnected.bind(this);\n\t\t\tthis.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n\t\t\twindow.addEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.addEventListener('offline', this.offlineNetworkHandler);\n\t\t\tawait this.userAgent.start();\n\t\t\tif (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n\t\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync onConnected(): Promise<void> {\n\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\tthis.state.isReady = true;\n\t\tthis.sendOptions();\n\t\tthis.networkEmitter.emit('connected');\n\t\t/**\n\t\t * Re-registration post network recovery should be attempted\n\t\t * if it was previously registered or incall/onhold\n\t\t */\n\n\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\tthis.attemptRegistration = true;\n\t\t}\n\t}\n\n\tonDisconnected(error: any): void {\n\t\tthis._connectionState = 'SERVER_DISCONNECTED';\n\t\tthis._opInProgress = Operation.OP_NONE;\n\t\tthis.networkEmitter.emit('disconnected');\n\t\tif (error) {\n\t\t\tthis.networkEmitter.emit('connectionerror', error);\n\t\t\tthis.state.isReady = false;\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted assuming\n\t\t\t * that the disconnect happened from the remote side or due to sleep\n\t\t\t * In case of remote side disconnection, if config.connectionRetryCount is -1,\n\t\t\t * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n\t\t\t *\n\t\t\t */\n\t\t\t// this.attemptReconnection();\n\t\t\tthis.attemptReconnection(0, false);\n\t\t}\n\t}\n\n\tonNetworkRestored(): void {\n\t\tthis.networkEmitter.emit('localnetworkonline');\n\t\tif (this._connectionState === 'WAITING_FOR_NETWORK') {\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted when online event handler\n\t\t\t * gets notified.\n\t\t\t * Important thing to note is that the second parameter |checkRegistration| = true passed here\n\t\t\t * because after the network recovery and after reconnecting to the server,\n\t\t\t * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n\t\t\t * the code will check if the endpoint was previously registered before the disconnection.\n\t\t\t * If such is the case, it will first unregister and then re-register.\n\t\t\t * */\n\t\t\tthis.attemptReconnection();\n\t\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\t\tthis.attemptRegistration = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tonNetworkLost(): void {\n\t\tthis.networkEmitter.emit('localnetworkoffline');\n\t\tthis._connectionState = 'WAITING_FOR_NETWORK';\n\t}\n\n\tget userConfig(): VoIPUserConfiguration {\n\t\treturn this.config;\n\t}\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget connectionState(): ConnectionState {\n\t\treturn this._connectionState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (\n\t\t\tthis.callState === 'IN_CALL' ||\n\t\t\tthis.callState === 'OFFER_RECEIVED' ||\n\t\t\tthis.callState === 'ON_HOLD' ||\n\t\t\tthis.callState === 'OFFER_SENT'\n\t\t) {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonRegistrationRequestAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonRegistrationRequestReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprotected setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tthis.emit('ringing', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tif (this._userState === UserState.UAC) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We need to decide about user-state ANSWER-RECEIVED for outbound.\n\t\t\t\t\t\t * This state is there for the symmetry of ANSWER-SENT.\n\t\t\t\t\t\t * ANSWER-SENT occurs when there is incoming invite. So then the UA\n\t\t\t\t\t\t * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n\t\t\t\t\t\t * The call gets established only when the remote party sends ACK.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * But in case of UAC where the invite is sent out, there is no intermediate\n\t\t\t\t\t\t * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n\t\t\t\t\t\t * it sends ack and changes the SessionState to established.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * */\n\t\t\t\t\t\tthis._callState = 'ANSWER_RECEIVED';\n\t\t\t\t\t}\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.emit('callestablished', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream is undefined.');\n\t\t}\n\n\t\tthis.remoteStream = new RemoteStream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Sends SIP OPTIONS message to asterisk\n\t *\n\t * There is an interesting problem that happens with Asterisk.\n\t * After websocket connection succeeds and if there is no SIP\n\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t *\n\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t * This problem could be solved in multiple ways. One is that\n\t * whenever disconnect happens make sure that the socket is connected back using\n\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t * every 30 seconds till we send register message.\n\t *\n\t * Another approach is to send SIP OPTIONS just to tell server that\n\t * there is a UA using this socket. This is implemented below\n\t */\n\n\tsendOptions(outgoingRequestDelegate?: OutgoingRequestDelegate): void {\n\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\tif (outgoingMessage) {\n\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n\t\t}\n\t}\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Something is wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wrong');\n\t}\n\n\t/* Helper routines for checking call actions BEGIN */\n\n\tprivate canRejectCall(): boolean {\n\t\treturn ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\tprivate canEndOrHoldCall(): boolean {\n\t\treturn ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\t/* Helper routines for checking call actions END */\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canRejectCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tif (this.session instanceof Inviter) {\n\t\t\t\t\treturn this.session.cancel();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis._opInProgress = Operation.OP_CLEANUP;\n\t\t/** Socket reconnection is attempted when the socket is disconnected with some error.\n\t\t * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n\t\t * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n\t\t * if the socket is disconnected with error, connection attempts are not started or\n\t\t * if there are any previously ongoing attempts, they should be terminated.\n\t\t * flag attemptReconnect is used for ensuring this.\n\t\t */\n\t\tthis.stop = true;\n\t\tthis.userAgent?.stop();\n\t\tthis.registerer?.dispose();\n\t\tthis._connectionState = 'STOP';\n\n\t\tif (this.userAgent) {\n\t\t\tthis.userAgent.transport.onConnect = undefined;\n\t\t\tthis.userAgent.transport.onDisconnect = undefined;\n\t\t\twindow.removeEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.removeEventListener('offline', this.offlineNetworkHandler);\n\t\t}\n\t}\n\n\tonNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.on(event, handler);\n\t}\n\n\toffNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.off(event, handler);\n\t}\n\n\t/**\n\t * Connection is lost in 3 ways\n\t * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n\t * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n\t * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n\t * These event listeners would be get called when the browser detects that network is offline or online.\n\t * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n\t * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n\t * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n\t * unregister and then re-register.\n\t * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n\t * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n\t * if done inline.\n\t *\n\t * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n\t * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n\t * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n\t *\n\t * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n\t * As soon as the agent successfully connects to asterisk, it should re-register\n\t *\n\t * Retry count :\n\t * connectionRetryCount is the parameter called |Retry Count| in\n\t * Administration -> Call Center -> Server configuration -> Retry count.\n\t * The retry is implemented with backoff, maxbackoff = 8 seconds.\n\t * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n\t *\n\t * Important to note is how attemptRegistrationPostRecovery is called. In case of\n\t * the router connection loss or while switching the networks,\n\t * there is no disconnect and connect event from the transport layer of the userAgent.\n\t * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n\t * attemptRegistrationPostRecovery.\n\t * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n\t * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n\t */\n\n\tasync attemptReconnection(reconnectionAttempt = 0, checkRegistration = false): Promise<void> {\n\t\tconst reconnectionAttempts = this.connectionRetryCount;\n\t\tthis._connectionState = 'SERVER_RECONNECTING';\n\t\tif (!this.userAgent) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.stop) {\n\t\t\treturn;\n\t\t}\n\t\t// reconnectionAttempts == -1 then keep continuously trying\n\t\tif (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n\n\t\tconsole.error(`Attempting to reconnect with backoff due to network loss. Backoff time [${reconnectionDelay}]`);\n\t\tsetTimeout(() => {\n\t\t\tif (this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState === 'SERVER_CONNECTED') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.userAgent\n\t\t\t\t?.reconnect()\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tthis.attemptReconnection(++reconnectionAttempt, checkRegistration);\n\t\t\t\t});\n\t\t}, reconnectionDelay * 1000);\n\t}\n\n\tasync attemptPostRecoveryRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tthis.sendOptions({\n\t\t\tonAccept: (): void => {\n\t\t\t\tthis.attemptPostRecoveryRegistrationRoutine();\n\t\t\t},\n\t\t\tonReject: (error: unknown): void => {\n\t\t\t\tconsole.error(`[${error}] Failed to do options in attemptPostRecoveryRoutine()`);\n\t\t\t},\n\t\t});\n\t}\n\n\tasync sendKeepAliveAndWaitForResponse(withDebounce = false): Promise<boolean> {\n\t\tconst promise = new Promise<boolean>((resolve, reject) => {\n\t\t\tlet keepAliveAccepted = false;\n\t\t\tlet responseWaitTime = this.optionsKeepaliveInterval / 2;\n\t\t\tif (withDebounce) {\n\t\t\t\tresponseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\n\t\t\t}\n\n\t\t\tthis.sendOptions({\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tkeepAliveAccepted = true;\n\t\t\t\t},\n\t\t\t\tonReject: (_error: unknown): void => {\n\t\t\t\t\tconsole.error('Failed to do options.');\n\t\t\t\t},\n\t\t\t});\n\t\t\tsetTimeout(async () => {\n\t\t\t\tif (!keepAliveAccepted) {\n\t\t\t\t\treject(false);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.attemptRegistration) {\n\t\t\t\t\t\tthis.attemptPostRecoveryRoutine();\n\t\t\t\t\t\tthis.attemptRegistration = false;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t}, responseWaitTime * 1000);\n\t\t});\n\t\treturn promise;\n\t}\n\n\tasync startOptionsPingForUnstableNetworks(): Promise<void> {\n\t\tsetTimeout(async () => {\n\t\t\tif (!this.userAgent || this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState !== 'SERVER_RECONNECTING') {\n\t\t\t\tlet isConnected = false;\n\t\t\t\ttry {\n\t\t\t\t\tawait this.sendKeepAliveAndWaitForResponse();\n\t\t\t\t\tisConnected = true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(`[${e}] Failed to do options ping.`);\n\t\t\t\t} finally {\n\t\t\t\t\t// Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n\t\t\t\t\t!isConnected && this.networkEmitter.emit('disconnected');\n\t\t\t\t\tisConnected && this.networkEmitter.emit('connected');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Each seconds check if the network can reach asterisk. If not, try to reconnect\n\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t}, this.optionsKeepaliveInterval * 1000);\n\t}\n\n\tasync attemptPostRecoveryRegistrationRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tconst promise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.registerer?.unregister({\n\t\t\t\tall: true,\n\t\t\t\trequestDelegate: {\n\t\t\t\t\tonAccept: (): void => {\n\t\t\t\t\t\t_resolve();\n\t\t\t\t\t},\n\t\t\t\t\tonReject: (error): void => {\n\t\t\t\t\t\tconsole.error(`[${error}] While unregistering after recovery`);\n\t\t\t\t\t\tthis.emit('unregistrationerror', error);\n\t\t\t\t\t\t_reject('Error in Unregistering');\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t\ttry {\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[${error}] While waiting for unregister promise`);\n\t\t}\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonReject: (error): void => {\n\t\t\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\t\t\tthis.emit('registrationerror', error);\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\tasync changeAudioInputDevice(constraints: MediaStreamConstraints): Promise<boolean> {\n\t\tif (!this.session) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No session. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst newStream = await LocalStream.requestNewStream(constraints, this.session);\n\t\tif (!newStream) {\n\t\t\tconsole.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No peer connection. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tLocalStream.replaceTrack(peerConnection, newStream, 'audio');\n\t\treturn true;\n\t}\n\n\t// Commenting this as Video Configuration is not part of the scope for now\n\t// async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n\t// \tif (!this.session) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n\t// \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n\t// \tif (!newStream) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t// \tif (!peerConnection) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n\t// \treturn true;\n\t// }\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\tasync makeCallURI(_callee: string, _mediaRenderer?: IMediaStreamRenderer): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tasync makeCall(_calleeNumber: string): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n",null],"names":["Operation","UserState","WorkflowTypes","Emitter","UserAgent","Invitation","SessionState","Registerer","RequestPendingError","Inviter","URI","SessionDescriptionHandler","toggleMediaStreamTracks","LocalStream","QueueAggregator","RemoteStream","module","export","VoIPUser","link","default","operationInProgress","_opInProgress","userState","_userState","constructor","config","mediaRenderer","state","isReady","enableVideo","remoteStream","userAgentOptions","userAgent","registerer","mediaStreamRendered","_connectionState","_held","mode","queueInfo","connectionRetryCount","stop","networkEmitter","offlineNetworkHandler","onlineNetworkHandler","optionsKeepaliveInterval","optionsKeepAliveDebounceTimeInSec","attemptRegistration","session","_callState","_callerInfo","IDLE","OP_NONE","onNetworkRestored","bind","onNetworkLost","init","sipUri","concat","authUserName","sipRegistrarHostnameOrIP","transportOptions","server","webSocketURI","connectionTimeout","keepAliveInterval","sdpFactoryOptions","iceGatheringTimeout","peerConnectionConfiguration","iceServers","delegate","onInvite","invitation","handleIncomingCall","authorizationPassword","authPassword","authorizationUsername","uri","makeURI","sessionDescriptionHandlerFactoryOptions","logConfiguration","logLevel","transport","isConnected","OP_CONNECT","onConnect","onConnected","onDisconnect","onDisconnected","window","addEventListener","start","enableKeepAliveUsingOptionsForUnstableNetworks","startOptionsPingForUnstableNetworks","error","sendOptions","emit","callState","attemptReconnection","userConfig","connectionState","callerInfo","Error","caller","localMediaStream","_this$session","sdh","sessionDescriptionHandler","onRegistrationRequestAccept","OP_REGISTER","OP_UNREGISTER","onRegistrationRequestReject","OP_PROCESS_INVITE","UAS","setupSessionEventHandlers","callerId","remoteIdentity","user","callerName","displayName","host","reject","_this$session2","stateChange","addListener","_this$remoteStream","Initial","Establishing","callInfo","Established","UAC","setupRemoteMedia","Terminating","Terminated","undefined","clear","onTrackAdded","_event","console","log","onTrackRemoved","_this$session3","_this$mediaStreamRend","remoteMediaStream","mediaElement","remoteMediaElement","play","handleMuteUnmute","muteState","_this$session4","_this$session5","Promise","resolve","peerConnection","invite","requestDelegate","onAccept","onReject","then","catch","_this$session6","id","handleHoldUnhold","holdState","_this$session7","_this$session8","sessionDescriptionHandlerOptions","sessionDescriptionHandlerOptionsReInvite","hold","_this$session9","create","voip","outgoingRequestDelegate","_this$userAgent","_this$userAgent2","outgoingMessage","userAgentCore","makeOutgoingRequestMessage","request","register","_this$registerer","unregister","_this$registerer2","all","acceptCall","videoInvite","body","indexOf","invitationAcceptOptions","constraints","audio","video","accept","canRejectCall","includes","canEndOrHoldCall","rejectCall","endCall","cancel","bye","muteCall","holdCall","switchMediaRenderer","setWorkflowMode","CONTACT_CENTER_USER","setMembershipSubscription","subscription","_this$queueInfo","setMembership","getAggregator","getRegistrarState","_this$registerer3","toString","toLocaleLowerCase","_this$userAgent3","_this$registerer4","OP_CLEANUP","dispose","removeEventListener","onNetworkEvent","event","handler","on","offNetworkEvent","off","reconnectionAttempt","arguments","length","checkRegistration","reconnectionAttempts","reconnectionDelay","Math","pow","setTimeout","_this$userAgent4","reconnect","attemptPostRecoveryRoutine","attemptPostRecoveryRegistrationRoutine","sendKeepAliveAndWaitForResponse","withDebounce","promise","keepAliveAccepted","responseWaitTime","_error","e","_this$registerer6","_resolve","_reject","_this$registerer5","changeAudioInputDevice","_this$session10","warn","newStream","requestNewStream","replaceTrack","makeCallURI","_callee","_mediaRenderer","makeCall","_calleeNumber"],"mappings":"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"}