)]}'
{"version":3,"sources":["meteor://ðŸ’»app/client/lib/minimongo/sort.ts","meteor://ðŸ’»app/<anon>"],"sourcesContent":["import { compareBSONValues } from './bson';\nimport { isEmptyArray } from './comparisons';\nimport { createLookupFunction } from './lookups';\nimport type { Sort } from './types';\n\nconst createSortSpecParts = <T>(\n\tspec: Sort,\n): {\n\tlookup: (doc: T) => unknown[];\n\tascending: boolean;\n}[] => {\n\tif (Array.isArray(spec)) {\n\t\treturn spec.map((value) => {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn {\n\t\t\t\t\tlookup: createLookupFunction<T>(value),\n\t\t\t\t\tascending: true,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tlookup: createLookupFunction<T>(value[0]),\n\t\t\t\tascending: value[1] !== 'desc',\n\t\t\t};\n\t\t});\n\t}\n\n\treturn Object.entries(spec).map(([key, value]) => ({\n\t\tlookup: createLookupFunction<T>(key),\n\t\tascending: value >= 0,\n\t}));\n};\n\nconst reduceValue = (branchValues: unknown[], ascending: boolean): unknown =>\n\t([] as unknown[])\n\t\t.concat(\n\t\t\t...branchValues.map<unknown[]>((branchValue) => {\n\t\t\t\tif (!Array.isArray(branchValue)) {\n\t\t\t\t\treturn [branchValue];\n\t\t\t\t}\n\n\t\t\t\tif (isEmptyArray(branchValue)) {\n\t\t\t\t\treturn [undefined];\n\t\t\t\t}\n\n\t\t\t\treturn branchValue;\n\t\t\t}),\n\t\t)\n\t\t.reduce((reduced, value) => {\n\t\t\tconst cmp = compareBSONValues(reduced, value);\n\t\t\tif ((ascending && cmp > 0) || (!ascending && cmp < 0)) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t});\n\nexport const compileSort = (spec: Sort): ((a: unknown, b: unknown) => number) => {\n\tconst sortSpecParts = createSortSpecParts(spec);\n\n\tif (sortSpecParts.length === 0) {\n\t\treturn (): number => 0;\n\t}\n\n\treturn (a: unknown, b: unknown): number => {\n\t\tfor (let i = 0; i < sortSpecParts.length; ++i) {\n\t\t\tconst specPart = sortSpecParts[i];\n\t\t\tconst aValue = reduceValue(specPart.lookup(a), specPart.ascending);\n\t\t\tconst bValue = reduceValue(specPart.lookup(b), specPart.ascending);\n\t\t\tconst compare = compareBSONValues(aValue, bValue);\n\n\t\t\tif (compare !== 0) {\n\t\t\t\treturn specPart.ascending ? compare : -compare;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t};\n};\n",null],"names":["compareBSONValues","isEmptyArray","createLookupFunction","module","export","compileSort","createSortSpecParts","spec","Array","isArray","map","value","lookup","ascending","Object","entries","_ref","key","reduceValue","branchValues","concat","branchValue","undefined","reduce","reduced","cmp","sortSpecParts","length","a","b","i","specPart","aValue","bValue","compare"],"mappings":"2BAA2CA,EAAAC,EAAAC,EAA3CC,EAAOC,MAAE,CAAA,CAAAC,YAAiB,IAAEA,CAAc,GAACF,EAAAA,IAAAA,CAAAA,SAAAA,CAAAH,kBAAAA,CAAAA,EAAAA,EAAAA,CAAA,CAAA,EAAA,GAAAG,EAAAA,IAAAA,CAAAA,gBAAAA,CAAAF,aAAAA,CAAAA,EAAAA,EAAAA,CAAA,CAAA,EAAA,GAAAE,EAAAA,IAAAA,CAAAA,YAAAA,CAAAD,qBAAAA,CAAAA,EAAAA,EAAAA,CAAA,CAAA,EAAA,GAK3C,IAAMI,EACLC,GAKA,AAAIC,MAAMC,OAAO,CAACF,GACVA,EAAKG,GAAG,CAAEC,GAChB,AAAI,AAAiB,UAAjB,OAAOA,EACH,CACNC,OAAQV,EAAwBS,GAChCE,UAAW,CAAA,GAIN,CACND,OAAQV,EAAwBS,CAAK,CAAC,EAAE,EACxCE,UAAWF,AAAa,SAAbA,CAAK,CAAC,EAAE,GAKfG,OAAOC,OAAO,CAACR,GAAMG,GAAG,CAACM,IAAA,GAAC,CAACC,EAAKN,EAAM,CAAAK,EAAA,MAAM,CAClDJ,OAAQV,EAAwBe,GAChCJ,UAAWF,GAAS,EACpB,GAGIO,EAAc,CAACC,EAAyBN,IAC5C,EAAgB,CACfO,MAAM,IACHD,EAAaT,GAAG,CAAaW,GAC/B,AAAKb,MAAMC,OAAO,CAACY,GAIfpB,EAAaoB,GACT,CAACC,KAAAA,EAAU,CAGZD,EAPC,CAACA,EAAY,GAUtBE,MAAM,CAAC,CAACC,EAASb,KACjB,IAAMc,EAAMzB,EAAkBwB,EAASb,UACvC,AAAKE,GAAaY,EAAM,GAAO,CAACZ,GAAaY,EAAM,EAC3Cd,EAGDa,CACR,GAEWnB,EAAeE,IAC3B,IAAMmB,EAAgBpB,EAAoBC,UAE1C,AAAImB,AAAyB,IAAzBA,EAAcC,MAAM,CAChB,IAAc,EAGf,CAACC,EAAYC,KACnB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAcC,MAAM,CAAE,EAAEG,EAAG,CAC9C,IAAMC,EAAWL,CAAa,CAACI,EAAE,CAC3BE,EAASd,EAAYa,EAASnB,MAAM,CAACgB,GAAIG,EAASlB,SAAS,EAC3DoB,EAASf,EAAYa,EAASnB,MAAM,CAACiB,GAAIE,EAASlB,SAAS,EAC3DqB,EAAUlC,EAAkBgC,EAAQC,GAE1C,GAAIC,AAAY,IAAZA,EACH,OAAOH,EAASlB,SAAS,CAAGqB,EAAU,CAACA,EAIzC,OAAO,CACR,CACD"}