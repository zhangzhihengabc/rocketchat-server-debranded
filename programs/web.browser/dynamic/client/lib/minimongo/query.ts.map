)]}'
{"version":3,"sources":["meteor://ðŸ’»app/client/lib/minimongo/query.ts","meteor://ðŸ’»app/<anon>"],"sourcesContent":["import { compareBSONValues, getBSONType } from './bson';\nimport { equals, flatSome, isObject, some } from './comparisons';\nimport { createLookupFunction } from './lookups';\nimport type { BSONType, FieldExpression, Query } from './types';\n\nconst isArrayOfFields = <T>(values: unknown[]): values is T[] =>\n\tvalues.every((value) => ['number', 'string', 'symbol'].includes(typeof value));\n\nconst $in = <T extends string>(operand: T[], _options: undefined): ((value: T) => boolean) => {\n\tlet index: Record<T, T> | null = null;\n\tif (isArrayOfFields<T>(operand)) {\n\t\tindex = {} as Record<T, T>;\n\t\tfor (const operandElement of operand) {\n\t\t\tindex[operandElement] = operandElement;\n\t\t}\n\t}\n\n\treturn (value: T): boolean =>\n\t\tsome(value, (x) => {\n\t\t\tif (typeof x === 'string' && index !== null) {\n\t\t\t\treturn !!index[x];\n\t\t\t}\n\n\t\t\treturn operand.some((operandElement) => equals(operandElement, x));\n\t\t});\n};\n\nconst $nin = <T extends string>(operand: T[], _options: undefined): ((value: T) => boolean) => {\n\tconst isIn = $in(operand, undefined);\n\n\treturn (value: T): boolean => {\n\t\tif (value === undefined) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !isIn(value);\n\t};\n};\n\nconst $all =\n\t<T>(operand: T[], _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean => {\n\t\tif (!Array.isArray(value)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn operand.every((operandElement) => value.some((valueElement) => equals(operandElement, valueElement)));\n\t};\n\nconst $lt =\n\t<T>(operand: T, _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\tflatSome(value, (x) => compareBSONValues(x, operand) < 0);\n\nconst $lte =\n\t<T>(operand: T, _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\tflatSome(value, (x) => compareBSONValues(x, operand) <= 0);\n\nconst $gt =\n\t<T>(operand: T, _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\tflatSome(value, (x) => compareBSONValues(x, operand) > 0);\n\nconst $gte =\n\t<T>(operand: T, _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\tflatSome(value, (x) => compareBSONValues(x, operand) >= 0);\n\nconst $ne =\n\t<T>(operand: T, _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\t!some(value, (x) => equals(x, operand));\n\nconst $exists =\n\t<T>(operand: boolean, _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\toperand === (value !== undefined);\n\nconst $mod =\n\t<T>([divisor, remainder]: [number, number], _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\tflatSome(value, (x) => Number(x) % divisor === remainder);\n\nconst $size =\n\t<T>(operand: number, _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\tArray.isArray(value) && operand === value.length;\n\nconst $type =\n\t<T>(operand: BSONType, _options: undefined): ((value: T) => boolean) =>\n\t(value: T): boolean => {\n\t\tif (value === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn flatSome(value, (x) => getBSONType(x) === operand);\n\t};\n\nconst $regex = <T>(operand: string | RegExp, options: string): ((value: T) => boolean) => {\n\tlet regex: RegExp;\n\n\tif (options !== undefined) {\n\t\tconst regexSource = operand instanceof RegExp ? operand.source : operand;\n\t\tregex = new RegExp(regexSource, options);\n\t} else if (!(operand instanceof RegExp)) {\n\t\tregex = new RegExp(operand);\n\t}\n\n\treturn (value: T): boolean => {\n\t\tif (value === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn flatSome(value, (x) => regex.test(String(x)));\n\t};\n};\n\nconst $elemMatch = <T>(operand: Query<T>, _options: undefined): ((value: T) => boolean) => {\n\tconst matcher = compileDocumentSelector(operand);\n\n\treturn (value: T): boolean => {\n\t\tif (!Array.isArray(value)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn value.some((x) => matcher(x));\n\t};\n};\n\nconst $not = <T>(operand: FieldExpression<T>, _options: undefined): ((value: T) => boolean) => {\n\tconst matcher = compileValueSelector(operand);\n\treturn (value: T): boolean => !matcher(value);\n};\n\nconst dummyOperator =\n\t<T>(_operand: unknown, _options: undefined): ((value: T) => boolean) =>\n\t(_value: T): boolean =>\n\t\ttrue;\n\nconst $options = dummyOperator;\nconst $near = dummyOperator;\nconst $geoIntersects = dummyOperator;\n\nconst valueOperators = {\n\t$in,\n\t$nin,\n\t$all,\n\t$lt,\n\t$lte,\n\t$gt,\n\t$gte,\n\t$ne,\n\t$exists,\n\t$mod,\n\t$size,\n\t$type,\n\t$regex,\n\t$elemMatch,\n\t$not,\n\t$options,\n\t$near,\n\t$geoIntersects,\n} as const;\n\nconst $and = <T>(subSelector: Query<T>[]): ((doc: T) => boolean) => {\n\tconst subSelectorFunctions = subSelector.map(compileDocumentSelector);\n\treturn (doc: T): boolean => subSelectorFunctions.every((f) => f(doc));\n};\n\nconst $or = <T>(subSelector: Query<T>[]): ((doc: T) => boolean) => {\n\tconst subSelectorFunctions = subSelector.map(compileDocumentSelector);\n\treturn (doc: T): boolean => subSelectorFunctions.some((f) => f(doc));\n};\n\nconst $nor = <T>(subSelector: Query<T>[]): ((doc: T) => boolean) => {\n\tconst subSelectorFunctions = subSelector.map(compileDocumentSelector);\n\treturn (doc: T): boolean => subSelectorFunctions.every((f) => !f(doc));\n};\n\nconst $where = <T>(selectorValue: string | ((doc: T) => boolean)): ((doc: T) => boolean) => {\n\tconst fn = selectorValue instanceof Function ? selectorValue : Function(`return ${selectorValue}`);\n\treturn (doc: T): boolean => !!fn.call(doc);\n};\n\nconst logicalOperators = {\n\t$and,\n\t$or,\n\t$nor,\n\t$where,\n} as const;\n\nconst isValueOperator = (operator: string): operator is keyof typeof valueOperators => operator in valueOperators;\n\nconst isLogicalOperator = (operator: string): operator is keyof typeof logicalOperators => operator in logicalOperators;\n\nconst hasValueOperators = <T>(valueSelector: FieldExpression<T>): boolean =>\n\tObject.keys(valueSelector).every((key) => key.slice(0, 1) === '$');\n\nconst compileUndefinedOrNullSelector =\n\t<T>(): ((value: T) => boolean) =>\n\t(value: T): boolean =>\n\t\tflatSome(value, (x) => x === undefined || x === null);\n\nconst compilePrimitiveSelector =\n\t<T>(primitive: T) =>\n\t(value: T): boolean =>\n\t\tflatSome(value, (x) => x === primitive);\n\nconst compileRegexSelector =\n\t<T>(regex: RegExp) =>\n\t(value: T): boolean => {\n\t\tif (value === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn flatSome(value, (x) => regex.test(String(x)));\n\t};\n\nconst compileArraySelector =\n\t<T>(expected: T) =>\n\t(value: T): boolean => {\n\t\tif (!Array.isArray(value)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn some(value, (x) => equals(expected, x));\n\t};\n\nconst compileValueOperatorsSelector = <T>(expression: FieldExpression<T>): ((value: T) => boolean) => {\n\tconst operatorFunctions: ((value: T) => boolean)[] = [];\n\tfor (const operator of Object.keys(expression) as (keyof FieldExpression<T>)[]) {\n\t\tif (!isValueOperator(operator)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst operand = expression[operator];\n\t\tconst operation = valueOperators[operator] as unknown as (operand: unknown, options: unknown) => (value: T) => boolean;\n\t\toperatorFunctions.push(operation(operand, expression.$options));\n\t}\n\treturn (value: T): boolean => operatorFunctions.every((f) => f(value));\n};\n\nconst compileValueSelector = <T>(valueSelector: FieldExpression<T>[keyof FieldExpression<T>]): ((value: T) => boolean) => {\n\tif (valueSelector === undefined || valueSelector === null) {\n\t\treturn compileUndefinedOrNullSelector();\n\t}\n\n\tif (!isObject(valueSelector)) {\n\t\treturn compilePrimitiveSelector(valueSelector as T);\n\t}\n\n\tif (valueSelector instanceof RegExp) {\n\t\treturn compileRegexSelector(valueSelector);\n\t}\n\n\tif (Array.isArray(valueSelector)) {\n\t\treturn compileArraySelector(valueSelector as unknown as T);\n\t}\n\n\tif (hasValueOperators<T>(valueSelector)) {\n\t\treturn compileValueOperatorsSelector(valueSelector);\n\t}\n\n\treturn (value: T): boolean => flatSome(value, (x) => equals(valueSelector, x as unknown as object));\n};\n\nexport const compileDocumentSelector = <T>(docSelector: Query<T> | FieldExpression<T>['$where'][]): ((doc: T) => boolean) => {\n\tconst perKeySelectors = Object.entries(docSelector).map(([key, subSelector]) => {\n\t\tif (subSelector === undefined) {\n\t\t\treturn (): boolean => true;\n\t\t}\n\n\t\tif (isLogicalOperator(key)) {\n\t\t\tswitch (key) {\n\t\t\t\tcase '$and':\n\t\t\t\t\treturn $and(subSelector);\n\n\t\t\t\tcase '$or':\n\t\t\t\t\treturn $or(subSelector);\n\n\t\t\t\tcase '$nor':\n\t\t\t\t\treturn $nor(subSelector);\n\n\t\t\t\tcase '$where':\n\t\t\t\t\treturn $where(subSelector);\n\t\t\t}\n\t\t}\n\n\t\tconst lookUpByIndex = createLookupFunction(key);\n\t\tconst valueSelectorFunc = compileValueSelector(subSelector);\n\t\treturn (doc: T): boolean => {\n\t\t\tconst branchValues = lookUpByIndex(doc);\n\t\t\treturn branchValues.some(valueSelectorFunc);\n\t\t};\n\t});\n\n\treturn (doc: T): boolean => perKeySelectors.every((f) => f(doc));\n};\n",null],"names":["compareBSONValues","getBSONType","equals","flatSome","isObject","some","createLookupFunction","module","export","compileDocumentSelector","isArrayOfFields","values","every","value","includes","$in","operand","_options","index","operandElement","x","dummyOperator","_operand","_value","valueOperators","$nin","isIn","undefined","$all","Array","isArray","valueElement","$lt","$lte","$gt","$gte","$ne","$exists","$mod","_ref","divisor","remainder","Number","$size","length","$type","$regex","options","regex","regexSource","RegExp","source","test","String","$elemMatch","matcher","$not","compileValueSelector","$options","$near","$geoIntersects","$and","subSelector","subSelectorFunctions","map","doc","f","$or","$nor","$where","selectorValue","fn","Function","concat","call","logicalOperators","isValueOperator","operator","isLogicalOperator","hasValueOperators","valueSelector","Object","keys","key","slice","compileUndefinedOrNullSelector","compilePrimitiveSelector","primitive","compileRegexSelector","compileArraySelector","expected","compileValueOperatorsSelector","expression","operatorFunctions","operation","push","docSelector","perKeySelectors","entries","_ref2","lookUpByIndex","valueSelectorFunc","branchValues"],"mappings":"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"}