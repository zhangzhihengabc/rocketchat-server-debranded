function module(t,e,r){let i,s,o,n,a,c,h,y,d,l,p,E,u,g,S,m,R,D,I,A,f,k,K,T,w,O,_,b,x,C,N;let Y=["_id"];r.link("@babel/runtime/helpers/objectSpread2",{default(t){i=t}},0),r.link("@babel/runtime/helpers/objectWithoutProperties",{default(t){s=t}},1),r.export({E2ERoom:()=>M}),r.link("@rocket.chat/base64",{Base64(t){o=t}},0),r.link("@rocket.chat/emitter",{Emitter(t){n=t}},1),r.link("@rocket.chat/random",{Random(t){a=t}},2),r.link("ejson",{default(t){c=t}},3),r.link("../../../client/lib/RoomManager",{RoomManager(t){h=t}},4),r.link("../../../client/lib/rooms/roomCoordinator",{roomCoordinator(t){y=t}},5),r.link("../../../definition/IRoomTypeConfig",{RoomSettingsEnum(t){d=t}},6),r.link("../../models/client",{ChatRoom(t){l=t},Subscriptions(t){p=t},Messages(t){E=t}},7),r.link("../../notifications/client",{Notifications(t){u=t}},8),r.link("../../utils/client/lib/SDKClient",{sdk(t){g=t}},9),r.link("./E2ERoomState",{E2ERoomState(t){S=t}},10),r.link("./helper",{toString(t){m=t},toArrayBuffer(t){R=t},joinVectorAndEcryptedData(t){D=t},splitVectorAndEcryptedData(t){I=t},encryptRSA(t){A=t},encryptAES(t){f=t},decryptRSA(t){k=t},decryptAES(t){K=t},generateAESKey(t){T=t},exportJWKKey(t){w=t},importAESKey(t){O=t},importRSAKey(t){_=t},readFileAsArrayBuffer(t){b=t}},11),r.link("./logger",{log(t){x=t},logError(t){C=t}},12),r.link("./rocketchat.e2e",{e2e(t){N=t}},13);let G=Symbol("keyID"),v=Symbol("PAUSED"),P={[S.NOT_STARTED]:[S.ESTABLISHING,S.DISABLED,S.KEYS_RECEIVED],[S.READY]:[S.DISABLED],[S.ERROR]:[S.KEYS_RECEIVED,S.NOT_STARTED],[S.WAITING_KEYS]:[S.KEYS_RECEIVED,S.ERROR,S.DISABLED],[S.ESTABLISHING]:[S.READY,S.KEYS_RECEIVED,S.ERROR,S.DISABLED,S.WAITING_KEYS]},U=(t,e)=>t===e?e===S.ERROR:!!(!(t in P)||P[t].includes(e))&&e;class M extends n{constructor(t,e,r){super(),this.state=void 0,this[v]=void 0,this.userId=t,this.roomId=e,this.typeOfRoom=r,this.once(S.READY,()=>this.decryptPendingMessages()),this.once(S.READY,()=>this.decryptSubscription()),this.on("STATE_CHANGED",t=>{this.roomId===h.opened&&this.log("[PREV: ".concat(t,"]"),"State CHANGED")}),this.on("STATE_CHANGED",()=>this.handshake()),this.setState(S.NOT_STARTED)}log(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];x("E2E ROOM { state: ".concat(this.state,", rid: ").concat(this.roomId," }"),...e)}error(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];C("E2E ROOM { state: ".concat(this.state,", rid: ").concat(this.roomId," }"),...e)}setState(t){let e=this.state,r=U(e,t);if(!r){this.error("invalid state ".concat(e," -> ").concat(t));return}this.state=r,this.log(e,"->",r),this.emit("STATE_CHANGED",e,r,this),this.emit(r,this)}isReady(){return this.state===S.READY}isDisabled(){return this.state===S.DISABLED}enable(){this.state!==S.READY&&this.setState(S.READY)}disable(){this.setState(S.DISABLED)}pause(){this.log("PAUSED",this[v],"->",!0),this[v]=!0,this.emit("PAUSED",!0)}resume(){this.log("PAUSED",this[v],"->",!1),this[v]=!1,this.emit("PAUSED",!1)}keyReceived(){this.setState(S.KEYS_RECEIVED)}async shouldConvertSentMessages(t){return!!this.isReady()&&!this[v]&&(void 0===this[v]?new Promise(t=>{this.once("PAUSED",t)}):"/"!==t.msg[0])}shouldConvertReceivedMessages(){return this.isReady()}isWaitingKeys(){return this.state===S.WAITING_KEYS}get keyID(){return this[G]}set keyID(t){this[G]=t}async decryptSubscription(){var t;let e=p.findOne({rid:this.roomId}),r=await ((null===(t=e.lastMessage)||void 0===t?void 0:t.msg)&&this.decrypt(e.lastMessage.msg));if(!(null!=r&&r.text)){this.log("decryptSubscriptions nothing to do");return}p.update({_id:e._id},{$set:{"lastMessage.msg":r.text,"lastMessage.e2e":"done"}}),this.log("decryptSubscriptions Done")}async decryptPendingMessages(){return E.find({rid:this.roomId,t:"e2e",e2e:"pending"}).forEach(async t=>{let{_id:e}=t,r=s(t,Y);E.update({_id:e},await this.decryptMessage(r))})}async handshake(){if(this.state===S.KEYS_RECEIVED||this.state===S.NOT_STARTED){this.setState(S.ESTABLISHING);try{let t=p.findOne({rid:this.roomId}).E2EKey;if(t){await this.importGroupKey(t),this.setState(S.READY);return}}catch(t){this.setState(S.ERROR),this.error("Error fetching group key: ",t);return}try{let t=l.findOne({_id:this.roomId});if(!t.e2eKeyId){this.setState(S.CREATING_KEYS),await this.createGroupKey(),this.setState(S.READY);return}this.setState(S.WAITING_KEYS),this.log("Requesting room key"),u.notifyUsersOfRoom(this.roomId,"e2ekeyRequest",this.roomId,t.e2eKeyId)}catch(t){this.setState(S.ERROR)}}}isSupportedRoomType(t){return y.getRoomDirectives(t).allowRoomSettingChange({},d.E2E)}async importGroupKey(t){this.log("Importing room key ->",this.roomId),t=t.slice(12),t=o.decode(t);try{let e=await k(N.privateKey,t);this.sessionKeyExportedString=m(e)}catch(t){return this.error("Error decrypting group key: ",t),!1}this.keyID=o.encode(this.sessionKeyExportedString).slice(0,12);try{let t=await O(JSON.parse(this.sessionKeyExportedString));this.groupSessionKey=t}catch(t){return this.error("Error importing group key: ",t),!1}return!0}async createGroupKey(){this.log("Creating room key");try{this.groupSessionKey=await T()}catch(t){throw console.error("Error generating group key: ",t),t}try{let t=await w(this.groupSessionKey);this.sessionKeyExportedString=JSON.stringify(t),this.keyID=o.encode(this.sessionKeyExportedString).slice(0,12),await g.call("e2e.setRoomKeyID",this.roomId,this.keyID),await this.encryptKeyForOtherParticipants()}catch(t){throw this.error("Error exporting group key: ",t),t}}async encryptKeyForOtherParticipants(){try{let{users:t}=await g.call("e2e.getUsersOfRoomWithoutKey",this.roomId);t.forEach(t=>this.encryptForParticipant(t))}catch(t){return this.error("Error getting room users: ",t)}}async encryptForParticipant(t){let e;try{e=await _(JSON.parse(t.e2e.public_key),["encrypt"])}catch(t){return this.error("Error importing user key: ",t)}try{let r=await A(e,R(this.sessionKeyExportedString));await g.call("e2e.updateGroupKey",this.roomId,t._id,this.keyID+o.encode(new Uint8Array(r)))}catch(t){return this.error("Error encrypting user key: ",t)}}async encryptFile(t){let e;if(!this.isSupportedRoomType(this.typeOfRoom))return;let r=await b(t),i=crypto.getRandomValues(new Uint8Array(16));try{e=await f(i,this.groupSessionKey,r)}catch(t){return this.error("Error encrypting group key: ",t)}let s=D(i,e),o=new File([R(c.stringify(s))],t.name);return o}async decryptFile(t){if("{"!==t[0])return;let[e,r]=I(c.parse(t));try{return await K(e,this.groupSessionKey,r)}catch(t){return this.error("Error decrypting file: ",t),!1}}async encryptText(t){let e;if("function"==typeof t||"object"==typeof t&&t||(t=new TextEncoder("UTF-8").encode(c.stringify({text:t,ack:a.id((a.fraction()+1)*20)}))),!this.isSupportedRoomType(this.typeOfRoom))return t;let r=crypto.getRandomValues(new Uint8Array(16));try{e=await f(r,this.groupSessionKey,t)}catch(t){return this.error("Error encrypting message: ",t)}return this.keyID+o.encode(D(r,e))}encrypt(t){let e=new Date,r=new TextEncoder("UTF-8").encode(c.stringify({_id:t._id,text:t.msg,userId:this.userId,ts:e}));return this.encryptText(r)}async decryptMessage(t){if("e2e"!==t.t||"done"===t.e2e)return t;let e=await this.decrypt(t.msg);return null!=e&&e.text?i(i({},t),{},{msg:e.text,e2e:"done"}):t}async decrypt(t){if(!this.isSupportedRoomType(this.typeOfRoom))return t;let e=t.slice(0,12);if(e!==this.keyID)return t;t=t.slice(12);let[r,i]=I(o.decode(t));try{let t=await K(r,this.groupSessionKey,i);return c.parse(new TextDecoder("UTF-8").decode(new Uint8Array(t)))}catch(e){return this.error("Error decrypting message: ",e,t)}}provideKeyToUser(t){this.keyID===t&&this.encryptKeyForOtherParticipants()}}}
//# sourceMappingURL=/dynamic/app/e2e/client/2cfc46198800a74866ec0352d59ddd2808f2968d.map
