function module(r,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});let o=r("../../compile/codegen"),i=r("../discriminator/types"),t=r("../../compile"),s=r("../../compile/util");e.default={keyword:"discriminator",type:"object",schemaType:"object",error:{message:({params:{discrError:r,tagName:e}})=>r===i.DiscrError.Tag?`tag "${e}" must be string`:`value of tag "${e}" must be in oneOf`,params:({params:{discrError:r,tag:e,tagName:i}})=>(0,o._)`{error: ${r}, tag: ${i}, tagValue: ${e}}`},code(r){let{gen:e,data:n,schema:a,parentSchema:c,it:l}=r,{oneOf:u}=c;if(!l.opts.discriminator)throw Error("discriminator: requires discriminator option");let m=a.propertyName;if("string"!=typeof m)throw Error("discriminator: requires propertyName");if(a.mapping)throw Error("discriminator: mapping is not supported");if(!u)throw Error("discriminator: requires oneOf keyword");let f=e.let("valid",!1),d=e.const("tag",(0,o._)`${n}${(0,o.getProperty)(m)}`);e.if((0,o._)`typeof ${d} == "string"`,()=>(function(){let n=function(){var r;let e={},o=n(c),i=!0;for(let e=0;e<u.length;e++){let c=u[e];(null==c?void 0:c.$ref)&&!(0,s.schemaHasRulesButRef)(c,l.self.RULES)&&(c=t.resolveRef.call(l.self,l.schemaEnv.root,l.baseId,null==c?void 0:c.$ref))instanceof t.SchemaEnv&&(c=c.schema);let f=null===(r=null==c?void 0:c.properties)||void 0===r?void 0:r[m];if("object"!=typeof f)throw Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${m}"`);i=i&&(o||n(c)),function(r,e){if(r.const)a(r.const,e);else if(r.enum)for(let o of r.enum)a(o,e);else throw Error(`discriminator: "properties/${m}" must have "const" or "enum"`)}(f,e)}if(!i)throw Error(`discriminator: "${m}" must be required`);return e;function n({required:r}){return Array.isArray(r)&&r.includes(m)}function a(r,o){if("string"!=typeof r||r in e)throw Error(`discriminator: "${m}" values must be unique strings`);e[r]=o}}();for(let i in e.if(!1),n)e.elseIf((0,o._)`${d} === ${i}`),e.assign(f,function(i){let t=e.name("valid"),s=r.subschema({keyword:"oneOf",schemaProp:i},t);return r.mergeEvaluated(s,o.Name),t}(n[i]));e.else(),r.error(!1,{discrError:i.DiscrError.Mapping,tag:d,tagName:m}),e.endIf()})(),()=>r.error(!1,{discrError:i.DiscrError.Tag,tag:d,tagName:m})),r.ok(f)}}}
//# sourceMappingURL=/dynamic/node_modules/ajv/dist/vocabularies/discriminator/a0ba4be7bb5aee04864441844be0905cbe256208.map
